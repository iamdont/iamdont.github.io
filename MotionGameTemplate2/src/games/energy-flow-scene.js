// src/scenes/energy-flow-scene.js

// === 核心修改：移除所有 import ===
// import { getPalmCenterFromPose } from '../utils.js'; // 刪除呢句

class PointSmoother { /* ... 不變 ... */ constructor(smoothingFactor = 0.8) { this.smoothingFactor = smoothingFactor; this.smoothedPoint = null; } update(rawPoint) { if (!rawPoint) { this.smoothedPoint = null; return null; } if (!this.smoothedPoint) { this.smoothedPoint = { ...rawPoint }; } else { this.smoothedPoint.x = this.smoothingFactor * this.smoothedPoint.x + (1 - this.smoothingFactor) * rawPoint.x; this.smoothedPoint.y = this.smoothingFactor * this.smoothedPoint.y + (1 - this.smoothingFactor) * rawPoint.y; } return this.smoothedPoint; } reset() { this.smoothedPoint = null; } }

export class EnergyFlowScene {
    // ...
    updateHandPosition() {
        if (this.gameState !== 'playing' || !this.latestPoseLandmarks) {
            this.hand.isVisible = false;
            return;
        }
        
        // === 核心修改：直接調用全局函數 ===
        const rawHandPoint = window.getPalmCenterFromPose(this.latestPoseLandmarks, 'left');
        
        const smoothedPos = this.handSmoother.update(rawHandPoint);
        // ...後面不變
        if (smoothedPos) { this.hand.isVisible = true; this.hand.prevPos = { ...this.hand.pos }; this.hand.pos.x = (1 - smoothedPos.x) * this.canvas.width; this.hand.pos.y = smoothedPos.y * this.canvas.height; this.hand.speed = Math.hypot(this.hand.pos.x - this.hand.prevPos.x, this.hand.pos.y - this.hand.prevPos.y); } else { this.hand.isVisible = false; this.hand.speed = 0; }
    }
    // ... 其他所有 EnergyFlowScene 嘅代碼同我上次提供嘅完全一樣，不變 ...
    constructor() { this.loopHandle = null; this.resultsListener = null; this.canvas = null; this.ctx = null; this.ui = {}; this.latestPoseLandmarks = null; this.handSmoother = new PointSmoother(0.85); this.gameState = 'playing'; this.hand = { pos: { x: -100, y: -100 }, prevPos: { x: -100, y: -100 }, speed: 0, isVisible: false }; this.orb = { pos: { x: 0, y: 0 }, vel: { x: 0, y: 0 }, radius: 20, isAttached: false }; this.path = []; this.progress = 0; this.config = { maxSpeed: 15, attachDistance: 80, springConstant: 0.04, damping: 0.75, pathTolerance: 50 }; this.reattachCooldownTimer = null; }
    render() { return ` <style> .ef-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #0c0c1e; font-family: 'Segoe UI', sans-serif; } .ef-scene #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; } .ef-scene #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; color: white; pointer-events: none; display: flex; flex-direction: column; align-items: center; } .ef-scene #progress-bar-container { width: 50%; height: 10px; background-color: rgba(255,255,255,0.2); margin-top: 20px; border-radius: 5px; } .ef-scene #progress-bar { width: 0%; height: 100%; background-color: #00f2ff; border-radius: 5px; transition: width 0.2s linear; } .ef-scene #message-container { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; } .ef-scene #message { font-size: 3em; font-weight: bold; text-shadow: 0 0 10px #00f2ff; } .ef-scene #restart-button { padding: 15px 30px; font-size: 1.5em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; pointer-events: auto; display: none; } </style> <div class="ef-scene"> <a class="back-button" data-scene-changer="launcher" data-motion-activatable> <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg> </a> <canvas id="game-canvas"></canvas> <div id="game-ui"> <div id="progress-bar-container"><div id="progress-bar"></div></div> <div id="message-container"> <h2 id="message"></h2> <button id="restart-button" data-motion-activatable>Restart</button> </div> </div> </div> `; }
    init() { window.motionEngine.setMode('pose'); window.motionEngine.setPointerHand('left'); window.motionEngine.outputCanvas.style.display = 'block'; this.canvas = document.getElementById('game-canvas'); this.ctx = this.canvas.getContext('2d'); this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; this.ui.progressBar = document.getElementById('progress-bar'); this.ui.messageEl = document.getElementById('message'); this.ui.restartBtn = document.getElementById('restart-button'); this._bindEvents(); this.startGame(); }
    destroy() { if (this.reattachCooldownTimer) clearTimeout(this.reattachCooldownTimer); console.log("Destroying EnergyFlowScene..."); if (this.loopHandle) cancelAnimationFrame(this.loopHandle); window.motionEngine.setPointerHand('right'); window.motionEngine.setMode('hands'); const removeListener = (listeners, handler) => { if (listeners && handler) { const index = listeners.indexOf(handler); if (index > -1) listeners.splice(index, 1); } }; removeListener(window.motionEngine.eventListeners.get('results-updated'), this.resultsListener); }
    _bindEvents() { document.querySelector('.back-button[data-scene-changer]').addEventListener('click', (e) => window.sceneManager.loadScene(e.currentTarget.dataset.sceneChanger)); this.ui.restartBtn.addEventListener('click', () => this.startGame()); this.resultsListener = (results) => { this.latestPoseLandmarks = results.poseLandmarks; }; window.motionEngine.on('results-updated', this.resultsListener); }
    startGame() { if (this.reattachCooldownTimer) clearTimeout(this.reattachCooldownTimer); this.gameState = 'playing'; this.hand = { pos: { x: -100, y: -100 }, prevPos: { x: -100, y: -100 }, speed: 0, isVisible: false }; this.handSmoother.reset(); this.definePath(); this.orb = { pos: { ...this.path[0] }, vel: { x: 0, y: 0 }, radius: 20, isAttached: false }; this.progress = 0; this.ui.messageEl.textContent = 'Guide the orb along the path'; this.ui.restartBtn.style.display = 'none'; setTimeout(() => { if (this.gameState === 'playing') this.ui.messageEl.textContent = '' }, 3000); if (!this.loopHandle) this.gameLoop(); }
    definePath() { this.path = []; const w = this.canvas.width, h = this.canvas.height, segments = 200; for (let i = 0; i <= segments; i++) { const t = i / segments; const x = w * 0.1 + t * w * 0.8; const y = h / 2 + Math.sin(t * Math.PI * 2) * h * 0.25; this.path.push({ x, y }); } }
    update() { if (this.gameState !== 'playing') return; this.updateHandPosition(); let closestDistToPath = Infinity; let closestSegment = 0; for (let i = 0; i < this.path.length; i++) { const dist = Math.hypot(this.orb.pos.x - this.path[i].x, this.orb.pos.y - this.path[i].y); if (dist < closestDistToPath) { closestDistToPath = dist; closestSegment = i; } } const distToHand = Math.hypot(this.hand.pos.x - this.orb.pos.x, this.hand.pos.y - this.orb.pos.y); const canReattach = this.reattachCooldownTimer === null; if (this.orb.isAttached) { if (this.hand.speed > this.config.maxSpeed || !this.hand.isVisible || closestDistToPath > this.config.pathTolerance * 1.5) { this.orb.isAttached = false; this.orb.vel.x = (this.hand.pos.x - this.hand.prevPos.x) * 0.5; this.orb.vel.y = (this.hand.pos.y - this.hand.prevPos.y) * 0.5; this.reattachCooldownTimer = setTimeout(() => { this.reattachCooldownTimer = null; }, 500); } } else { if (canReattach && this.hand.isVisible && this.hand.speed < 5 && distToHand < this.config.attachDistance && closestDistToPath < this.config.pathTolerance) { this.orb.isAttached = true; } else if (this.hand.isVisible && distToHand < this.config.attachDistance) { const pushForce = 0.2; const pushVectorX = (this.orb.pos.x - this.hand.pos.x) / distToHand; const pushVectorY = (this.orb.pos.y - this.hand.pos.y) / distToHand; this.orb.vel.x += pushVectorX * pushForce * this.hand.speed; this.orb.vel.y += pushVectorY * pushForce * this.hand.speed; } } if (this.orb.isAttached) { const forceX = (this.hand.pos.x - this.orb.pos.x) * this.config.springConstant; const forceY = (this.hand.pos.y - this.orb.pos.y) * this.config.springConstant; this.orb.vel.x = (this.orb.vel.x + forceX) * this.config.damping; this.orb.vel.y = (this.orb.vel.y + forceY) * this.config.damping; } else { this.orb.vel.x *= 0.98; this.orb.vel.y *= 0.98; } this.orb.pos.x += this.orb.vel.x; this.orb.pos.y += this.orb.vel.y; const r = this.orb.radius; if (this.orb.pos.x < r) { this.orb.pos.x = r; this.orb.vel.x *= -0.8; } if (this.orb.pos.x > this.canvas.width - r) { this.orb.pos.x = this.canvas.width - r; this.orb.vel.x *= -0.8; } if (this.orb.pos.y < r) { this.orb.pos.y = r; this.orb.vel.y *= -0.8; } if (this.orb.pos.y > this.canvas.height - r) { this.orb.pos.y = this.canvas.height - r; this.orb.vel.y *= -0.8; } if (this.orb.isAttached && closestDistToPath < this.config.pathTolerance) { const newProgress = (closestSegment / (this.path.length - 1)) * 100; if (newProgress > this.progress) this.progress = newProgress; } if (this.progress >= 100) { this.gameState = 'win'; this.ui.messageEl.textContent = 'Flow Complete!'; this.ui.restartBtn.style.display = 'block'; } }
    draw() { this.ctx.fillStyle = '#0c0c1e'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); if (this.latestPoseLandmarks) { this.ctx.save(); this.ctx.globalAlpha = 0.2; this.ctx.translate(this.canvas.width, 0); this.ctx.scale(-1, 1); drawConnectors(this.ctx, this.latestPoseLandmarks, POSE_CONNECTIONS, { color: 'white', lineWidth: 1 }); this.ctx.restore(); } this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; this.ctx.lineWidth = this.config.pathTolerance * 2; this.ctx.lineCap = 'round'; this.ctx.beginPath(); this.ctx.moveTo(this.path[0].x, this.path[0].y); for(let i = 1; i < this.path.length; i++) this.ctx.lineTo(this.path[i].x, this.path[i].y); this.ctx.stroke(); this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.4)'; this.ctx.lineWidth = 4; this.ctx.stroke(); if (this.hand.isVisible) { this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; this.ctx.beginPath(); this.ctx.arc(this.hand.pos.x, this.hand.pos.y, this.config.attachDistance, 0, 2 * Math.PI); this.ctx.fill(); } const orbColor = this.orb.isAttached ? '#00f2ff' : '#ff4d84'; const glowColor = this.orb.isAttached ? 'rgba(0, 242, 255, 0.5)' : 'rgba(255, 77, 132, 0.5)'; this.ctx.shadowColor = glowColor; this.ctx.shadowBlur = 30; this.ctx.fillStyle = orbColor; this.ctx.beginPath(); this.ctx.arc(this.orb.pos.x, this.orb.pos.y, this.orb.radius, 0, 2 * Math.PI); this.ctx.fill(); this.ctx.shadowBlur = 0; this.ui.progressBar.style.width = `${this.progress}%`; }
    gameLoop() { this.update(); this.draw(); this.loopHandle = requestAnimationFrame(() => this.gameLoop()); }
}