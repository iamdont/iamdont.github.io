// src/scenes/cup-knock-scene.js

const loadScript = (src) => { return new Promise((resolve, reject) => { if (document.querySelector(`script[src="${src}"]`)) { return resolve(); } const script = document.createElement('script'); script.src = src; script.onload = () => resolve(); script.onerror = () => reject(new Error(`Failed to load script: ${src}`)); document.head.appendChild(script); }); };

export class CupKnockScene {
    constructor() { this.loopHandle = null; this.resultsListener = null; this.matterEngine = null; this.matterRunner = null; this.platform = null; this.score = 0; this.isGameOver = false; }
    render() { return ` <style> .ck-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; cursor: none; } .ck-scene #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.25; pointer-events: none; transform: scaleX(-1); } .ck-scene #game-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; background: transparent; } .ck-scene #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); pointer-events: none; } .ck-scene #score, .ck-scene #message { position: absolute; left: 50%; transform: translateX(-50%); font-size: 3em; font-weight: bold; } .ck-scene #score { top: 20px; } .ck-scene #message { top: 50%; transform: translate(-50%, -50%); font-size: 4em; display: none; } .ck-scene #reset-button { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 15px 30px; font-size: 1.2em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; z-index: 4; pointer-events: auto; } </style> <div class="ck-scene"> <a class="back-button" data-scene-changer="launcher" data-motion-activatable> <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg> </a> <canvas id="skeleton-canvas"></canvas> <div id="game-canvas-container"></div> <div id="ui-layer"> <div id="score">Score: 0</div> <div id="message"></div> </div> <button id="reset-button" data-motion-activatable>Reset Game</button> </div> `; }
    async init() { try { await loadScript("https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"); window.motionEngine.setMode('hands'); window.motionEngine.outputCanvas.style.display = 'block'; this.skeletonCanvas = document.getElementById('skeleton-canvas'); this.skeletonCtx = this.skeletonCanvas.getContext('2d'); this.gameCanvasContainer = document.getElementById('game-canvas-container'); this.scoreElement = document.getElementById('score'); this.messageElement = document.getElementById('message'); this._setupPhysics(); this._bindEvents(); this.resetGame(); this.gameLoop(); } catch (error) { console.error("Failed to initialize CupKnockScene:", error); } }
    destroy() { if (this.loopHandle) { cancelAnimationFrame(this.loopHandle); } if (this.matterRunner) { Matter.Runner.stop(this.matterRunner); } if (this.matterEngine) { Matter.Engine.clear(this.matterEngine); } const removeListener = (listeners, handler) => { if (listeners && handler) { const index = listeners.indexOf(handler); if (index > -1) listeners.splice(index, 1); } }; removeListener(window.motionEngine.eventListeners.get('results-updated'), this.resultsListener); }
    _setupPhysics() { const { Engine, Render, Runner, World, Bodies } = Matter; this.matterEngine = Engine.create(); this.matterRunner = Runner.create(); const renderer = Render.create({ element: this.gameCanvasContainer, engine: this.matterEngine, options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' } }); this.matterEngine.world.gravity.y = 1.2; const w = window.innerWidth, h = window.innerHeight; const wallOptions = { isStatic: true, render: { visible: false } }; World.add(this.matterEngine.world, [ Bodies.rectangle(w / 2, h + 30, w, 60, wallOptions), Bodies.rectangle(-30, h / 2, 60, h, wallOptions), Bodies.rectangle(w + 30, h / 2, 60, h, wallOptions) ]); const platformY = h - 250, platformWidth = 400; this.platform = Bodies.rectangle(w / 2, platformY, platformWidth, 20, { isStatic: true, render: { fillStyle: '#e0e0e0' }, label: 'platform' }); World.add(this.matterEngine.world, this.platform); Render.run(renderer); Runner.run(this.matterRunner, this.matterEngine); }
    _bindEvents() { document.getElementById('reset-button').addEventListener('click', () => this.resetGame()); document.querySelector('.back-button[data-scene-changer]').addEventListener('click', (e) => { window.sceneManager.loadScene(e.currentTarget.dataset.sceneChanger); }); this.resultsListener = (results) => { const multiHandLandmarks = []; if (results.leftHandLandmarks) multiHandLandmarks.push(results.leftHandLandmarks); if (results.rightHandLandmarks) multiHandLandmarks.push(results.rightHandLandmarks); if (results.multiHandLandmarks) multiHandLandmarks.push(...results.multiHandLandmarks); if (results.image && multiHandLandmarks.length > 0) { this._drawSkeleton({ image: results.image, multiHandLandmarks }); } }; window.motionEngine.on('results-updated', this.resultsListener); }
    _drawSkeleton(results) { this.skeletonCanvas.width = window.innerWidth; this.skeletonCanvas.height = window.innerHeight; this.skeletonCtx.clearRect(0, 0, this.skeletonCanvas.width, this.skeletonCanvas.height); if (results.image) { this.skeletonCtx.drawImage(results.image, 0, 0, this.skeletonCanvas.width, this.skeletonCanvas.height); } if (results.multiHandLandmarks) { for (const landmarks of results.multiHandLandmarks) { drawConnectors(this.skeletonCtx, landmarks, HAND_CONNECTIONS, { color: '#FFFFFF', lineWidth: 2 }); drawLandmarks(this.skeletonCtx, landmarks, { color: '#FFD700', radius: 4 }); } } }
    resetGame() { this.isGameOver = false; this.updateScore(0); this.messageElement.style.display = 'none'; if (this.matterRunner.enabled === false) { this.matterRunner.enabled = true; } const world = this.matterEngine.world; Matter.Composite.allBodies(world).forEach(body => { if (!body.isStatic) { Matter.Composite.remove(world, body); } }); const cupWidth = 50, cupHeight = 70; const startY = this.platform.position.y - 10 - (cupHeight / 2); const startX = this.platform.position.x - (2 * cupWidth + 2 * 10); const cupOptions = { density: 0.005, friction: 0.8, restitution: 0.1, label: 'cup', sleepThreshold: 60 }; for (let i = 0; i < 5; i++) { const cupBody = Matter.Bodies.rectangle(startX + i * (cupWidth + 10), startY, cupWidth, cupHeight, { ...cupOptions, render: { fillStyle: '#4287f5' } }); cupBody.isScored = false; Matter.World.add(world, cupBody); } }
    
    // === 核心修改：遍歷新嘅 pointers 數組 ===
    checkCollisions() {
        const cups = Matter.Composite.allBodies(this.matterEngine.world).filter(b => b.label === 'cup');
        for (const pointer of window.motionEngine.pointers) {
            if (!pointer.isVisible) continue;
            const pointerHitbox = { x: (1 - pointer.x) * window.innerWidth, y: pointer.y * window.innerHeight, radius: 15 };
            for (const cup of cups) {
                const distance = Math.hypot(pointerHitbox.x - cup.position.x, pointerHitbox.y - cup.position.y);
                const collisionDistance = pointerHitbox.radius + (cup.bounds.max.x - cup.bounds.min.x) / 2;
                if (distance < collisionDistance) {
                    const direction = Matter.Vector.normalise(Matter.Vector.sub(cup.position, pointerHitbox));
                    if (direction.x === 0 && direction.y === 0) direction.y = -1;
                    Matter.Body.setVelocity(cup, { x: direction.x * 15, y: direction.y * 15 });
                }
            }
        }
    }
    // ===================================

    checkWinCondition() { if (this.isGameOver) return; let currentScore = 0; const platformTopY = this.platform.position.y - 10; Matter.Composite.allBodies(this.matterEngine.world).forEach(body => { if (body.label === 'cup') { const isTilted = Math.abs(body.angle) > Math.PI / 3; const hasFallenOff = body.position.y > platformTopY + 50; if (!body.isScored && (isTilted || hasFallenOff)) { body.isScored = true; body.render.fillStyle = '#888'; } if (body.isScored) { currentScore += 100; } } }); this.updateScore(currentScore); if (this.score >= 5 * 100) { this.isGameOver = true; this.messageElement.textContent = "You Win!"; this.messageElement.style.display = 'block'; this.matterRunner.enabled = false; } }
    updateScore(newScore) { if (this.score !== newScore) { this.score = newScore; this.scoreElement.textContent = `Score: ${this.score}`; } }
    gameLoop() { if (!this.isGameOver) { this.checkCollisions(); } this.checkWinCondition(); this.loopHandle = requestAnimationFrame(() => this.gameLoop()); }
}