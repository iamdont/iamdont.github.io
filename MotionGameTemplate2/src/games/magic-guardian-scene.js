// src/scenes/magic-guardian-scene.js

class GestureRecognizer { /* ... 不變 ... */ static getGesture(handLandmarks) { if (!handLandmarks) return 'none'; try { const wrist = handLandmarks[0]; const thumbTip = handLandmarks[4]; const indexTip = handLandmarks[8]; const middleTip = handLandmarks[12]; const ringTip = handLandmarks[16]; const pinkyTip = handLandmarks[20]; const isFist = this.distance(indexTip, wrist) < this.distance(handLandmarks[5], wrist) && this.distance(middleTip, wrist) < this.distance(handLandmarks[9], wrist) && this.distance(ringTip, wrist) < this.distance(handLandmarks[13], wrist) && this.distance(pinkyTip, wrist) < this.distance(handLandmarks[17], wrist); if (isFist) return 'fist'; const isFive = this.distance(thumbTip, pinkyTip) > 0.15 && this.distance(indexTip, wrist) > this.distance(handLandmarks[5], wrist); if (isFive) return 'open'; return 'none'; } catch (e) { return 'none'; } } static distance(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); } }

export class MagicGuardianScene {
    constructor() { /* ... 不變 ... */ this.loopHandle = null; this.resultsListener = null; this.canvas = null; this.ctx = null; this.ui = {}; this.player = { bodyHitbox: { x: 0, y: 0, rx: 0, ry: 0 }, leftHand: { x: -100, y: -100, radius: 65, gesture: 'none' }, rightHand: { x: -100, y: -100, radius: 65, gesture: 'none' } }; this.score = 0; this.lives = 5; this.isGameOver = false; this.fireballs = []; this.magicOrbs = []; this.particles = []; this.spawnInterval = null; }
    render() { /* ... 不變 ... */ return ` <style> .mg-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #112; } .mg-scene #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; } .mg-scene #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; color: white; text-shadow: 2px 2px 4px black; pointer-events: none; } .mg-scene #game-stats { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; font-size: 2em; font-weight: bold; } .mg-scene #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 10; display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; } .mg-scene #game-over-screen h2 { font-size: 5em; margin: 0; } .mg-scene #game-over-screen p { font-size: 1.5em; } .mg-scene #restart-button { padding: 15px 30px; font-size: 1.5em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; } .mg-scene .screen-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; opacity: 0; } .mg-scene .hit-flash { background-color: red; animation: flash 0.3s ease-out; } @keyframes flash { from { opacity: 0.7; } to { opacity: 0; } } </style> <div class="mg-scene"> <a class="back-button" data-scene-changer="launcher" data-motion-activatable> <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg> </a> <canvas id="output-canvas"></canvas> <div id="ui-layer"> <div id="game-stats"><div id="score">Score: 0</div><div id="lives">Lives: ❤️❤️❤️</div></div> </div> <div id="game-over-screen"> <h2>GAME OVER</h2><p id="final-score"></p> <button id="restart-button" data-motion-activatable>Restart Game</button> </div> <div id="screen-flash" class="screen-flash"></div> </div> `; }
    init() { /* ... 不變 ... */ window.motionEngine.setMode('holistic'); window.motionEngine.outputCanvas.style.display = 'block'; window.motionEngine.setPointerHand('left'); this.canvas = document.getElementById('output-canvas'); this.ctx = this.canvas.getContext('2d'); this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; this.ui.scoreEl = document.getElementById('score'); this.ui.livesEl = document.getElementById('lives'); this.ui.gameOverScreen = document.getElementById('game-over-screen'); this.ui.finalScoreEl = document.getElementById('final-score'); this.ui.restartBtn = document.getElementById('restart-button'); this.ui.screenFlashEl = document.getElementById('screen-flash'); this._bindEvents(); this.startGame(); }
    destroy() { /* ... 不變 ... */ console.log("Destroying MagicGuardianScene..."); if (this.spawnInterval) clearInterval(this.spawnInterval); window.motionEngine.setPointerHand('right'); window.motionEngine.setMode('hands'); const removeListener = (listeners, handler) => { if (listeners && handler) { const index = listeners.indexOf(handler); if (index > -1) listeners.splice(index, 1); } }; removeListener(window.motionEngine.eventListeners.get('results-updated'), this.resultsListener); }
    
    _bindEvents() { /* ... 不變 ... */ document.querySelector('.back-button[data-scene-changer]').addEventListener('click', (e) => { window.sceneManager.loadScene(e.currentTarget.dataset.sceneChanger); }); this.ui.restartBtn.addEventListener('click', () => this.startGame()); this.resultsListener = (results) => { this.onResults(results); }; window.motionEngine.on('results-updated', this.resultsListener); }
    onResults(results) { /* ... 不變 ... */ const w = this.canvas.width, h = this.canvas.height; this.ctx.save(); this.ctx.clearRect(0, 0, w, h); if (results.image) { this.ctx.translate(w, 0); this.ctx.scale(-1, 1); this.ctx.drawImage(results.image, 0, 0, w, h); this.ctx.restore(); } else { this.ctx.fillStyle = '#112'; this.ctx.fillRect(0, 0, w, h); this.ctx.restore(); } if (!this.isGameOver) { this.updatePlayerState(results); this.updateGameObjects(); this.checkCollisions(); } this.drawGameElements(); }
    startGame() { /* ... 不變 ... */ this.score = 0; this.lives = 5; this.isGameOver = false; this.fireballs = []; this.magicOrbs = []; this.particles = []; this.updateUI(); this.ui.gameOverScreen.style.display = 'none'; if (this.spawnInterval) clearInterval(this.spawnInterval); this.spawnInterval = setInterval(() => { if (this.isGameOver) return; this.spawnFireball(); if (Math.random() < 0.4) this.spawnMagicOrb(); }, 1200); }

    // === 核心修改：使用正確嘅坐標轉換 ===
    updatePlayerState(results) {
        const w = this.canvas.width, h = this.canvas.height;
        // 呢個 helper function 依家係啱嘅，因為 results 入面嘅坐標都係 0-1
        const getScreenCoord = (p) => p ? { x: (1 - p.x) * w, y: p.y * h } : null;

        if (results.poseLandmarks) {
            const [ls, rs, lh, rh] = [11, 12, 23, 24].map(i => results.poseLandmarks[i]);
            if (ls && rs && lh && rh && ls.visibility > 0.6 && rh.visibility > 0.6) {
                const lsPos = getScreenCoord(ls), rsPos = getScreenCoord(rs), lhPos = getScreenCoord(lh), rhPos = getScreenCoord(rh);
                this.player.bodyHitbox.x = (lsPos.x + rsPos.x) / 2;
                this.player.bodyHitbox.y = (lsPos.y + lhPos.y) / 2;
                this.player.bodyHitbox.rx = Math.abs(lsPos.x - rsPos.x) / 2 * 0.8;
                this.player.bodyHitbox.ry = Math.abs(lsPos.y - lhPos.y) / 2 * 0.9;
            }
        }
        
        const updateHand = (handSide, handLandmarks) => {
            const hand = this.player[handSide];
            hand.gesture = GestureRecognizer.getGesture(handLandmarks);
            if (handLandmarks) {
                const [wrist, indexMcp, pinkyMcp] = [0, 5, 17].map(i => handLandmarks[i]);
                if (wrist && indexMcp && pinkyMcp) {
                    const palmCenterX = (wrist.x + indexMcp.x + pinkyMcp.x) / 3;
                    const palmCenterY = (wrist.y + indexMcp.y + pinkyMcp.y) / 3;
                    // getScreenCoord 會處理鏡像同縮放
                    const screenPos = getScreenCoord({x: palmCenterX, y: palmCenterY});
                    if (screenPos) { hand.x = screenPos.x; hand.y = screenPos.y; }
                }
            }
        };
        updateHand('leftHand', results.leftHandLandmarks);
        updateHand('rightHand', results.rightHandLandmarks);
    }
    // ======================================

    // ... 後面所有嘅遊戲邏輯方法 (draw, update, spawn 等) 同之前一樣，不變 ...
    drawGameElements() { const { bodyHitbox, leftHand, rightHand } = this.player; this.ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)'; this.ctx.lineWidth = 1; this.ctx.beginPath(); this.ctx.ellipse(bodyHitbox.x, bodyHitbox.y, bodyHitbox.rx, bodyHitbox.ry, 0, 0, 2 * Math.PI); this.ctx.fill(); this.ctx.stroke(); this.drawHandCircle(this.ctx, leftHand); this.drawHandCircle(this.ctx, rightHand); this.fireballs.forEach(fb => { this.ctx.fillStyle = 'orange'; this.ctx.beginPath(); this.ctx.arc(fb.x, fb.y, fb.radius, 0, 2*Math.PI); this.ctx.fill(); }); this.magicOrbs.forEach(orb => { this.ctx.fillStyle = 'cyan'; this.ctx.beginPath(); this.ctx.arc(orb.x, orb.y, orb.radius, 0, 2*Math.PI); this.ctx.fill(); }); this.particles.forEach(p => { this.ctx.fillStyle = p.color; this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI); this.ctx.fill(); }); }
    spawnObject(type) { const w = this.canvas.width, h = this.canvas.height; const radius = type === 'fireball' ? 25 : 30; let x, y; const side = Math.floor(Math.random() * 3); switch (side) { case 0: x = -radius; y = Math.random() * h * 0.9; break; case 1: x = w + radius; y = Math.random() * h * 0.9; break; case 2: x = Math.random() * w; y = -radius; break; } const targetX = w / 2 + (Math.random() - 0.5) * 400; const targetY = h / 2 + (Math.random() - 0.5) * 300; const angle = Math.atan2(targetY - y, targetX - x); const speed = type === 'fireball' ? (2 + Math.random() * 2) : (1.5 + Math.random()); return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius, type }; }
    spawnFireball() { this.fireballs.push(this.spawnObject('fireball')); }
    spawnMagicOrb() { this.magicOrbs.push(this.spawnObject('magicOrb')); }
    createExplosion(x, y, color, count = 20) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = 2 + Math.random() * 4; this.particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: 2 + Math.random() * 3, life: 30 + Math.random() * 30, color }); } }
    updateGameObjects() { const move = (obj) => { obj.x += obj.vx; obj.y += obj.vy; }; this.fireballs.forEach(move); this.magicOrbs.forEach(move); this.particles.forEach(p => { move(p); p.life--; p.radius *= 0.98; }); const onScreen = (obj) => obj.x > -50 && obj.x < this.canvas.width + 50 && obj.y > -50 && obj.y < this.canvas.height + 50; this.fireballs = this.fireballs.filter(onScreen); this.magicOrbs = this.magicOrbs.filter(onScreen); this.particles = this.particles.filter(p => p.life > 0); }
    checkCollisions() { const isColliding = (c1, c2) => Math.hypot(c1.x - c2.x, c1.y - c2.y) < c1.radius + c2.radius; const isEllipseColliding = (e, c) => ((c.x - e.x) / (e.rx + c.radius)) ** 2 + ((c.y - e.y) / (e.ry + c.radius)) ** 2 < 1; for (let i = this.fireballs.length - 1; i >= 0; i--) { const fb = this.fireballs[i]; const leftHandDestroy = this.player.leftHand.gesture === 'fist' && isColliding(this.player.leftHand, fb); const rightHandDestroy = this.player.rightHand.gesture === 'fist' && isColliding(this.player.rightHand, fb); if (leftHandDestroy || rightHandDestroy) { this.score += 20; this.createExplosion(fb.x, fb.y, 'orange'); this.fireballs.splice(i, 1); this.updateUI(); } else if (isEllipseColliding(this.player.bodyHitbox, fb)) { this.lives--; this.createExplosion(fb.x, fb.y, 'red'); this.fireballs.splice(i, 1); this.updateUI(); this.ui.screenFlashEl.className = 'mg-scene screen-flash hit-flash'; setTimeout(() => this.ui.screenFlashEl.className = 'mg-scene screen-flash', 300); if (this.lives <= 0) { this.gameOver(); break; } } } for (let i = this.magicOrbs.length - 1; i >= 0; i--) { const orb = this.magicOrbs[i]; const leftHandCollect = this.player.leftHand.gesture === 'open' && isColliding(this.player.leftHand, orb); const rightHandCollect = this.player.rightHand.gesture === 'open' && isColliding(this.player.rightHand, orb); if (leftHandCollect || rightHandCollect) { this.score += 100; this.createExplosion(orb.x, orb.y, 'cyan'); this.magicOrbs.splice(i, 1); this.updateUI(); } } }
    gameOver() { this.isGameOver = true; this.ui.finalScoreEl.textContent = `Your Score: ${this.score}`; this.ui.gameOverScreen.style.display = 'flex'; }
    updateUI() { this.ui.scoreEl.textContent = `Score: ${this.score}`; this.ui.livesEl.textContent = `Lives: ${'❤️'.repeat(Math.max(0, this.lives))}`; }
    drawHandCircle(ctx, hand) { let color = 'rgba(100,100,100,0.5)', glowColor = 'transparent', strokeColor = 'rgba(200,200,200,0.7)'; if (hand.gesture === 'open') { color = 'rgba(0, 176, 255, 0.8)'; glowColor = '#00B0FF'; } else if (hand.gesture === 'fist') { color = 'rgba(255, 100, 0, 0.8)'; glowColor = '#FF8C00'; strokeColor = '#FFD700'; } ctx.shadowColor = glowColor; ctx.shadowBlur = hand.gesture !== 'none' ? 20 : 0; ctx.fillStyle = color; ctx.beginPath(); ctx.arc(hand.x, hand.y, hand.radius, 0, 2 * Math.PI); ctx.fill(); ctx.shadowBlur = 0; if (hand.gesture === 'fist') { ctx.strokeStyle = strokeColor; ctx.lineWidth = 4; ctx.stroke(); } }
}