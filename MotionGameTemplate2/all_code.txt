// \VSCode_Projects\MotionGameTemplate2\index.html 
<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Games Platform</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>
    <main id="app-container"></main>
    <script src="src/utils.js"></script>
    <script type="module" src="src/app.js"></script>
</body>
</html>
// \VSCode_Projects\MotionGameTemplate2\style.css 
/* ================= GLOBAL STYLES ================= */
:root {
    --bg-color: #1a1a1a;
    --text-color: #f0f0f0;
    --highlight-color: #ffd700;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    margin: 0;
    padding: 0;
    overflow: hidden; /* === 修改：改返做 hidden，唔要滾動條 === */
    cursor: none;
}

#app-container {
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* ================= LAUNCHER SCENE STYLES (大改) ================= */
.launcher-scene {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 4vh 4vw; /* 使用 vh/vw 單位做 padding */
    box-sizing: border-box;
}

.launcher-scene h1 {
    font-size: clamp(2em, 4vw, 2.5em); /* 響應式字體 */
    color: var(--highlight-color);
    margin: 0 0 4vh 0; /* 使用 vh 單位做 margin */
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    flex-shrink: 0; /* 唔好壓縮標題 */
}

.launcher-scene .launcher-grid {
    display: grid;
    /* === 修改：固定 4x2 佈局 === */
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(2, 1fr);
    gap: clamp(15px, 2vw, 25px); /* 響應式 gap */
    width: 100%;
    height: 100%;
    max-width: 1400px; /* 加個最大寬度限制，避免喺超寬屏拉得太開 */
}

.launcher-scene .card {
    background-color: #2b2b2b;
    border: 2px solid #444;
    border-radius: 12px;
    padding: clamp(15px, 2vh, 25px); /* 響應式 padding */
    text-decoration: none;
    color: var(--text-color);
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.3s;
    display: flex;
    flex-direction: column;
    justify-content: center; /* 改為置中 */
    align-items: center; /* 改為置中 */
    text-align: center; /* 文字置中 */
    cursor: none;
    pointer-events: auto;
}

.launcher-scene .card:hover, .launcher-scene .card.motion-hover {
    transform: scale(1.05); /* 移除 translateY，純放大 */
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
    border-color: var(--highlight-color);
}

.launcher-scene .card h2, .launcher-scene .card p, .launcher-scene .card .tags {
    pointer-events: none;
}

.launcher-scene h2 { margin: 0 0 10px 0; font-size: clamp(1.2em, 1.5vw, 1.5em); color: #fff; }
.launcher-scene p { display: none; } /* === 修改：暫時隱藏描述，節省空間 === */
.launcher-scene .tags { margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
.launcher-scene .tag { background-color: #555; color: #ddd; padding: 5px 10px; border-radius: 20px; font-size: clamp(0.7em, 1vw, 0.8em); font-weight: bold; }

/* ================= COMMON COMPONENTS ================= */
.back-button { position: fixed; top: 20px; left: 20px; z-index: 9990; width: 60px; height: 60px; background-color: rgba(0, 0, 0, 0.5); border: 2px solid #fff; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: none; transition: transform 0.2s, box-shadow 0.2s, border-color 0.3s; text-decoration: none; pointer-events: auto; }
.back-button:hover, .back-button.motion-hover { transform: scale(1.1); box-shadow: 0 0 15px rgba(255, 255, 255, 0.8); border-color: #ffd700; }
.back-button svg { width: 50%; height: 50%; fill: #fff; pointer-events: none; }
// \VSCode_Projects\MotionGameTemplate2\src\app.js 
// src/app.js
import { MotionEngine } from './motion-engine.js';
import { SceneManager } from './scene-manager.js';

class App {
    constructor() {
        // 將實例化嘅對象掛載到 window，方便全局訪問
        window.motionEngine = new MotionEngine();
        window.sceneManager = new SceneManager('app-container');
    }

    async init() {
        console.log("Motion Game Platform: Initializing...");
        
        try {
            await window.motionEngine.initialize();
            console.log("Motion Engine is online.");
            
            // 載入啟動場景
            window.sceneManager.loadScene('scenes/launcher');

        } catch (error) {
            console.error("Failed to initialize the app:", error);
            document.getElementById('app-container').innerHTML = `
                <div style="color: white; text-align: center; padding: 50px;">
                    <h1>初始化失敗</h1><p>無法啟動動作感應引擎。請確保您已授權瀏覽器使用相機，並刷新頁面重試。</p>
                    <p><em>錯誤詳情: ${error.message}</em></p>
                </div>`;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const app = new App();
    app.init();
});.
// \VSCode_Projects\MotionGameTemplate2\src\motion-engine.js 
// src/motion-engine.js

// 全局輔助函數，保持不變
window.getPalmCenterFromPose = function(landmarks, hand = 'right') { if (!landmarks) return null; const isLeft = hand === 'left'; const wristIdx = isLeft ? 15 : 16; const pinkyIdx = isLeft ? 17 : 18; const indexIdx = isLeft ? 19 : 20; const wrist = landmarks[wristIdx], pinky = landmarks[pinkyIdx], index = landmarks[indexIdx]; if (wrist && pinky && index && wrist.visibility > 0.3 && pinky.visibility > 0.3 && index.visibility > 0.3) { return { x: (wrist.x + pinky.x + index.x) / 3, y: (wrist.y + pinky.y + index.y) / 3 }; } return null; }
window.isPinching = function(handLandmarks, threshold = 0.04) { if (!handLandmarks || handLandmarks.length < 9) { return false; } const thumbTip = handLandmarks[4]; const indexTip = handLandmarks[8]; const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y); return distance < threshold; }

class PointSmoother {
    constructor(smoothingFactor = 0.8) { this.smoothingFactor = smoothingFactor; this.smoothedPoint = null; this.lastUpdateTime = 0; this.timeout = 100; }
    update(rawPoint) { const now = performance.now(); if (rawPoint) { this.lastUpdateTime = now; if (!this.smoothedPoint) this.smoothedPoint = { ...rawPoint }; else { this.smoothedPoint.x = this.smoothingFactor * this.smoothedPoint.x + (1 - this.smoothingFactor) * rawPoint.x; this.smoothedPoint.y = this.smoothingFactor * this.smoothedPoint.y + (1 - this.smoothingFactor) * rawPoint.y; } return this.smoothedPoint; } else { if (now - this.lastUpdateTime > this.timeout) this.smoothedPoint = null; return this.smoothedPoint; } }
    reset() { this.smoothedPoint = null; this.lastUpdateTime = 0; }
}

export class MotionEngine {
    constructor() {
        this.currentMode = null;
        this.detector = null;
        this.camera = null;
        this.isRunning = false;
        this.loopHandle = null;
        this.videoElement = null;
        this.outputCanvas = null;
        this.canvasCtx = null;
        this.results = {};
        this.eventListeners = new Map();
        this.pointers = [
            { id: 0, hand: 'left', smoother: new PointSmoother(0.7) },
            { id: 1, hand: 'right', smoother: new PointSmoother(0.7) }
        ].map(p => ({ ...p, x: 0, y: 0, isVisible: false, dwell: { element: null, startTime: 0, timer: null } }));
        this.pointer = { x: 0, y: 0, isVisible: false, hand: 'right' };
        this.config = {
            dwellActivationThreshold: 1500,
            dwellActivationCooldown: 300,
            pointerHand: 'right'
        };
        this.lastActivationTime = 0;
    }
    
    async initialize() {
        if (this.camera) return;
        this._createEngineElements();
        
        this.camera = new Camera(this.videoElement, {
            onFrame: async () => {
                if (this.detector && this.videoElement.readyState === 4) {
                    await this.detector.send({ image: this.videoElement });
                }
            },
            width: 1280,
            height: 720
        });

        await this.camera.start();
        this.isRunning = true;
        this._gameLoop();
    }
    
    setPointerHand(hand = 'right') {
        this.config.pointerHand = (hand === 'left' || hand === 'right') ? hand : 'right';
    }
    
    async setMode(newMode) {
        if (this.currentMode === newMode) return;
        console.log(`[MotionEngine] Switching mode from '${this.currentMode}' to '${newMode}'`);

        this.pointers.forEach(p => p.smoother.reset());

        if (this.detector) {
            await this.detector.close();
            this.detector = null;
        }
        
        this.results = {};
        this.currentMode = null;

        if (newMode === null || newMode === 'none') {
            this.emit('mode-changed', null);
            return;
        }

        try {
            const options = { locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/${newMode}/${file}` };
            let ModelClass, modelOptions;

            switch (newMode) {
                case 'hands':
                    ModelClass = window.Hands;
                    modelOptions = { maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 };
                    break;
                case 'pose':
                    ModelClass = window.Pose;
                    modelOptions = { modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 };
                    break;
                case 'holistic':
                    ModelClass = window.Holistic;
                    modelOptions = { modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.7 };
                    break;
                default:
                    throw new Error(`Unsupported mode: ${newMode}`);
            }

            this.detector = new ModelClass(options);
            this.detector.setOptions(modelOptions);
            this.detector.onResults(results => this._onResults(results));
            
            this.currentMode = newMode;
            console.log(`[MotionEngine] Mode '${newMode}' is set and ready.`);
            this.emit('mode-changed', newMode);

        } catch (error) {
            console.error(`[MotionEngine] Failed to set mode ${newMode}:`, error);
            this.currentMode = null;
        }
    }
    
    on(eventName, callback) {
        if (!this.eventListeners.has(eventName)) {
            this.eventListeners.set(eventName, []);
        }
        const listeners = this.eventListeners.get(eventName);
        listeners.push(callback);
        
        return () => { // 返回 unregister 函數
            const index = listeners.indexOf(callback);
            if (index > -1) listeners.splice(index, 1);
        };
    }
    
    emit(eventName, data) {
        if (this.eventListeners.has(eventName)) {
            [...this.eventListeners.get(eventName)].forEach(callback => callback(data));
        }
    }

    _createEngineElements() {
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = 'position:fixed; top:-1px; left:-1px; width:1px; height:1px;';
        document.body.appendChild(this.videoElement);
        
        this.outputCanvas = document.createElement('canvas');
        Object.assign(this.outputCanvas.style, {
            position: 'fixed', top: '0', left: '0',
            width: '100vw', height: '100vh', zIndex: '9999',
            pointerEvents: 'none', transform: 'scaleX(-1)', display: 'none'
        });
        document.body.appendChild(this.outputCanvas);

        this.canvasCtx = this.outputCanvas.getContext('2d');
        
        const resizeCanvas = () => {
            this.outputCanvas.width = window.innerWidth;
            this.outputCanvas.height = window.innerHeight;
        };
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    }
    
    _onResults(results) {
        this.results = results;
        this._updatePointers(results);
        this.emit('results-updated', results);
    }
    
    _updatePointers(results) {
        const handData = this.getHandsData(results);
        this.pointers.forEach(p => {
            const rawPoint = handData[p.hand];
            const smoothedPoint = p.smoother.update(rawPoint);
            p.isVisible = !!smoothedPoint;
            if (p.isVisible) {
                p.x = smoothedPoint.x;
                p.y = smoothedPoint.y;
            }
        });

        const primaryHand = this.config.pointerHand;
        const secondaryHand = primaryHand === 'right' ? 'left' : 'right';
        const activePointer = this.pointers.find(p => p.isVisible && p.hand === primaryHand) || this.pointers.find(p => p.isVisible && p.hand === secondaryHand);
        
        if (activePointer) {
            this.pointer.x = (1 - activePointer.x) * window.innerWidth;
            this.pointer.y = activePointer.y * window.innerHeight;
            this.pointer.isVisible = true;
            this.pointer.hand = activePointer.hand;
        } else {
            this.pointer.isVisible = false;
        }
    }
    
    getHandsData(results) {
        let hands = { left: null, right: null };
        if (this.currentMode === 'hands' && results.multiHandLandmarks && results.multiHandedness) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                if(results.multiHandedness[i]) {
                    const hand = results.multiHandedness[i].label.toLowerCase();
                    const target = results.multiHandLandmarks[i][8];
                    if (target) hands[hand] = { x: target.x, y: target.y };
                }
            }
        } else if (this.currentMode === 'holistic') {
            if (results.leftHandLandmarks) hands.left = { x: results.leftHandLandmarks[8].x, y: results.leftHandLandmarks[8].y };
            if (results.rightHandLandmarks) hands.right = { x: results.rightHandLandmarks[8].x, y: results.rightHandLandmarks[8].y };
        } else if (this.currentMode === 'pose' && results.poseLandmarks) {
            hands.left = window.getPalmCenterFromPose(results.poseLandmarks, 'left');
            hands.right = window.getPalmCenterFromPose(results.poseLandmarks, 'right');
        }
        return hands;
    }
    
    _updateHoverAndActivation() {
        const now = performance.now();
        if (now - this.lastActivationTime < this.config.dwellActivationCooldown) {
            this.pointers.forEach(p => this._clearDwell(p));
            return;
        }

        const activatableElements = document.querySelectorAll('[data-motion-activatable]');
        const allHoveredElements = new Set();

        this.pointers.forEach(p => {
            if (!p.isVisible) {
                this._clearDwell(p);
                return;
            }
            
            const screenX = (1 - p.x) * window.innerWidth;
            const screenY = p.y * window.innerHeight;
            
            let currentlyHovered = null;
            for (const el of activatableElements) {
                const rect = el.getBoundingClientRect();
                if (screenX >= rect.left && screenX <= rect.right && screenY >= rect.top && screenY <= rect.bottom) {
                    currentlyHovered = el;
                    break;
                }
            }

            if (p.dwell.element !== currentlyHovered) {
                this._clearDwell(p);
                if (currentlyHovered) {
                    p.dwell.element = currentlyHovered;
                    p.dwell.startTime = now;
                    p.dwell.timer = setTimeout(() => {
                        if (p.dwell.element) {
                            this.lastActivationTime = performance.now();
                            p.dwell.element.click();
                            this._clearDwell(p);
                        }
                    }, this.config.dwellActivationThreshold);
                }
            }

            if (p.dwell.element) {
                allHoveredElements.add(p.dwell.element);
            }
        });

        document.querySelectorAll('.motion-hover').forEach(el => {
            if (!allHoveredElements.has(el)) el.classList.remove('motion-hover');
        });
        allHoveredElements.forEach(el => el.classList.add('motion-hover'));
    }

    _clearDwell(pointer) {
        if (pointer.dwell.timer) clearTimeout(pointer.dwell.timer);
        if (pointer.dwell.element) pointer.dwell.element.classList.remove('motion-hover');
        pointer.dwell = { element: null, startTime: 0, timer: null };
    }
    
    _drawPointer() {
        const ctx = this.canvasCtx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        this.pointers.forEach(p => {
            if (!p.isVisible) return;
            const drawX = p.x * ctx.canvas.width, drawY = p.y * ctx.canvas.height;
            const color = p.hand === 'left' ? 'rgba(0, 255, 255, 1)' : 'rgba(255, 215, 0, 1)';
            if (p.dwell.element) {
                const progress = Math.min((performance.now() - p.dwell.startTime) / this.config.dwellActivationThreshold, 1);
                ctx.strokeStyle = color; ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(drawX, drawY, 20, -Math.PI / 2, -Math.PI / 2 + 2 * Math.PI * progress);
                ctx.stroke();
            }
            ctx.fillStyle = color.replace('1)', '0.7)');
            ctx.beginPath();
            ctx.arc(drawX, drawY, 15, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    _gameLoop() {
        if (!this.isRunning) return;
        this._updateHoverAndActivation();
        if (this.outputCanvas.style.display !== 'none') this._drawPointer();
        this.loopHandle = requestAnimationFrame(() => this._gameLoop());
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\scene-manager.js 
// src/scene-manager.js
export class SceneManager {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        if (!this.container) {
            throw new Error(`SceneManager: Container with id "${containerId}" not found.`);
        }
        this.currentScene = null;
        this.currentSceneName = null;
        this.isLoading = false; // 防止重複加載
    }

    async loadScene(sceneName, params = {}) {
        if (this.isLoading || this.currentSceneName === sceneName) {
            console.warn(`[SceneManager] Load request for "${sceneName}" ignored. (isLoading: ${this.isLoading}, isCurrent: ${this.currentSceneName === sceneName})`);
            return;
        }
        
        this.isLoading = true;
        console.log(`[SceneManager] Request to load scene: "${sceneName}"`);
        
        if (this.currentScene && typeof this.currentScene.destroy === 'function') {
            console.log(`[SceneManager] Destroying previous scene: "${this.currentSceneName}"...`);
            this.currentScene.destroy(); // 使用同步銷毀，確保資源在加載新場景前被釋放
        }
        
        this.currentScene = null;
        this.currentSceneName = sceneName;
        this.container.innerHTML = `<div style="color:white;text-align:center;padding-top:100px;font-size:2em;">Loading ${sceneName}...</div>`;

        try {
            // 所有 scene class file 都應以 "-scene.js" 結尾
            const modulePath = `/src/${sceneName}-scene.js`;
            
            console.log(`[SceneManager] Importing module from: "${modulePath}"`);
            const sceneModule = await import(modulePath);
            
            // 假設每個 scene file 只 export 一個 class
            const SceneClass = Object.values(sceneModule)[0];
            if (!SceneClass) {
                throw new Error(`No class exported from ${modulePath}`);
            }

            this.currentScene = new SceneClass(params);
            
            // 使用新嘅內部 mount 方法
            if (typeof this.currentScene.__internal_mount === 'function') {
                await this.currentScene.__internal_mount(this.container);
            } else {
                throw new Error(`Scene "${sceneName}" does not inherit from BaseScene or is improperly constructed.`);
            }

            console.log(`[SceneManager] Scene loaded successfully: "${sceneName}"`);

        } catch (error) {
            console.error(`[SceneManager] FATAL ERROR loading scene "${sceneName}":`, error);
            this.container.innerHTML = `<div style="color:red;text-align:center;padding:50px;">
                <h2>Error loading scene: ${sceneName}</h2>
                <p><strong>Please check the browser console for the exact error.</strong></p>
                <p>${error.message}</p>
            </div>`;
            this.currentScene = null;
            this.currentSceneName = null;
        } finally {
            this.isLoading = false;
        }
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\utils.js 
// src/utils.js

// getPalmCenterFromPose 和 isPinching 已經移到 motion-engine.js 成為全局函數

// 異步載入 3D 庫嘅輔助函數
window.load3DLibs = async function() {
    if (window.THREE && window.CANNON) {
        return [window.THREE, window.CANNON];
    }
    const threePromise = import('https://cdn.jsdelivr.net/npm/three@0.138.3/build/three.module.js');
    const cannonPromise = import('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm');
    
    // Promise.all 會並行載入，速度更快
    const [threeModule, cannonModule] = await Promise.all([threePromise, cannonPromise]);
    
    // 將佢哋掛載到 window object，方便後續直接調用
    window.THREE = threeModule;
    window.CANNON = cannonModule;
    
    return [window.THREE, window.CANNON];
}.
// \VSCode_Projects\MotionGameTemplate2\src\core\base-scene.js 
// src/core/base-scene.js
/**
 * @class BaseScene
 * @description 所有遊戲場景嘅抽象基類。
 * 負責處理通用嘅生命週期、事件綁定/解綁、以及 requestAnimationFrame 循環。
 * 遊戲開發者只需要繼承呢個類，並實現 onInit, onUpdate, onDraw, onDestroy 等方法。
 */
export class BaseScene {
    constructor(params = {}) {
        this.params = params;
        this.container = null;
        this.loopHandle = null;
        
        // Motion Engine 相關
        this.motionEngine = window.motionEngine; // 直接引用全局實例
        this.unsubscribeMotionResults = null;
        this.latestResults = null;
        
        this.sceneManager = window.sceneManager; // 直接引用全局實例
        this.eventHandlers = new Map(); // 用於儲存需要手動解綁嘅事件
    }

    /**
     * [內部] Scene Manager 調用嘅入口方法，負責渲染 HTML 同初始化
     * @param {HTMLElement} container - 將要掛載 Scene 嘅 DOM 元素
     */
    async __internal_mount(container) {
        this.container = container;
        this.container.innerHTML = this.renderHTML();
        
        this._bindBackButton();

        if (typeof this.onInit === 'function') {
            await this.onInit();
        }

        this.gameLoop();
        console.log(`[${this.constructor.name}] Mounted and Initialized.`);
    }

    /**
     * [內部] Scene Manager 調用嘅銷毀方法
     */
    destroy() {
        console.log(`[${this.constructor.name}] Starting destruction...`);
        
        if (this.loopHandle) {
            cancelAnimationFrame(this.loopHandle);
            this.loopHandle = null;
        }

        if (this.unsubscribeMotionResults) {
            this.unsubscribeMotionResults();
            this.unsubscribeMotionResults = null;
        }

        this._unbindAllManagedEvents();
        
        if (typeof this.onDestroy === 'function') {
            this.onDestroy();
        }
        
        if (this.container) {
            this.container.innerHTML = '';
            this.container = null;
        }
        
        // 重置 motion engine 到一個通用嘅狀態，避免影響下一個 scene
        // Launcher scene 會再 set 佢做 'hands'
        this.motionEngine.setMode('none'); 
        this.motionEngine.outputCanvas.style.display = 'none';

        console.log(`[${this.constructor.name}] Destroyed successfully.`);
    }

    /**
     * 遊戲主循環
     */
    gameLoop() {
        const now = performance.now();
        if (typeof this.onUpdate === 'function') {
            this.onUpdate(now);
        }
        if (typeof this.onDraw === 'function') {
            this.onDraw(now);
        }
        this.loopHandle = requestAnimationFrame(() => this.gameLoop());
    }

    // =================================================================
    // =========== 以下係需要子類去實現 (implement) 嘅方法 ============
    // =================================================================

    renderHTML() { throw new Error(`[${this.constructor.name}] Must implement renderHTML()`); }
    onInit() { /* Override in child class */ }
    onUpdate(timestamp) { /* Override in child class */ }
    onDraw(timestamp) { /* Override in child class */ }
    onDestroy() { /* Override in child class */ }

    // =================================================================
    // ==================== 輔助方法 (Helpers for Subclasses) ================
    // =================================================================

    /**
     * 受管理嘅事件監聽器。喺 Scene destroy 時會自動移除。
     * @param {EventTarget} element - 要綁定事件嘅元素
     * @param {string} eventName - 事件名稱
     * @param {Function} handler - 事件處理函數
     */
    addManagedEventListener(element, eventName, handler) {
        element.addEventListener(eventName, handler);
        if (!this.eventHandlers.has(element)) {
            this.eventHandlers.set(element, []);
        }
        this.eventHandlers.get(element).push({ eventName, handler });
    }

    /**
     * 訂閱 Motion Engine 的 results-updated 事件，並在 destroy 時自動取消訂閱
     */
    listenToMotionResults() {
        this.unsubscribeMotionResults = this.motionEngine.on('results-updated', (results) => {
            this.latestResults = results;
            if (typeof this.onResults === 'function') {
                this.onResults(results);
            }
        });
    }

    // =================================================================
    // ==================== 內部私有方法 (Private) ===================
    // =================================================================

    _bindBackButton() {
        const backButton = this.container.querySelector('.back-button');
        if (backButton) {
            const sceneChanger = backButton.dataset.sceneChanger;
            if (sceneChanger) {
                const handler = () => this.sceneManager.loadScene(sceneChanger);
                this.addManagedEventListener(backButton, 'click', handler);
            }
        }
    }

    _unbindAllManagedEvents() {
        for (const [element, handlers] of this.eventHandlers.entries()) {
            handlers.forEach(({ eventName, handler }) => {
                element.removeEventListener(eventName, handler);
            });
        }
        this.eventHandlers.clear();
        console.log(`[${this.constructor.name}] All managed event listeners removed.`);
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\cup-knock-scene.js 
// src/games/cup-knock-scene.js
import { BaseScene } from '../core/base-scene.js';

const loadScript = (src) => new Promise((resolve, reject) => {
    if (document.querySelector(`script[src="${src}"]`)) return resolve();
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
    document.head.appendChild(script);
});

export class CupKnockScene extends BaseScene {
    constructor() {
        super();
        this.matterEngine = null;
        this.matterRunner = null;
        this.matterRenderer = null;
        this.platform = null;
        this.skeletonCanvas = null;
        this.skeletonCtx = null;
        this.ui = {};
        this.score = 0;
        this.isGameOver = false;
    }

    renderHTML() {
        return `
            <style>
                .ck-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; cursor: none; }
                .ck-scene #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.25; pointer-events: none; transform: scaleX(-1); }
                .ck-scene #game-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; background: transparent; }
                .ck-scene #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); pointer-events: none; }
                .ck-scene #score, .ck-scene #message { position: absolute; left: 50%; transform: translateX(-50%); font-size: 3em; font-weight: bold; }
                .ck-scene #score { top: 20px; }
                .ck-scene #message { top: 50%; transform: translate(-50%, -50%); font-size: 4em; display: none; }
                .ck-scene #reset-button { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 15px 30px; font-size: 1.2em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; z-index: 4; pointer-events: auto; }
            </style>
            <div class="ck-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="skeleton-canvas"></canvas>
                <div id="game-canvas-container"></div>
                <div id="ui-layer">
                    <div id="score">Score: 0</div>
                    <div id="message"></div>
                </div>
                <button id="reset-button" data-motion-activatable>Reset Game</button>
            </div>
        `;
    }

    async onInit() {
        try {
            await loadScript("https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js");
            
            this.motionEngine.setMode('hands');
            this.motionEngine.outputCanvas.style.display = 'block';

            this.skeletonCanvas = document.getElementById('skeleton-canvas');
            this.skeletonCtx = this.skeletonCanvas.getContext('2d');
            this.ui.gameCanvasContainer = document.getElementById('game-canvas-container');
            this.ui.scoreElement = document.getElementById('score');
            this.ui.messageElement = document.getElementById('message');
            this.ui.resetButton = document.getElementById('reset-button');
            
            this.skeletonCanvas.width = window.innerWidth;
            this.skeletonCanvas.height = window.innerHeight;

            this._setupPhysics();
            
            this.addManagedEventListener(this.ui.resetButton, 'click', () => this.resetGame());
            this.listenToMotionResults();

            this.resetGame();

        } catch (error) {
            console.error("Failed to initialize CupKnockScene:", error);
            this.container.innerHTML = `<div style="color:red;">Error: ${error.message}</div>`;
        }
    }
    
    onDestroy() {
        if (this.matterRunner) {
            Matter.Runner.stop(this.matterRunner);
            this.matterRunner = null;
        }
        if (this.matterRenderer) {
            Matter.Render.stop(this.matterRenderer);
            if (this.matterRenderer.canvas) {
                this.matterRenderer.canvas.remove();
            }
            this.matterRenderer = null;
        }
        if (this.matterEngine) {
            Matter.World.clear(this.matterEngine.world);
            Matter.Engine.clear(this.matterEngine);
            this.matterEngine = null;
        }

        this.platform = null;
        this.ui = {};
        console.log("[CupKnockScene] Matter.js resources completely destroyed.");
    }

    onUpdate() {
        if (this.isGameOver) return;
        this.checkCollisions();
        this.checkWinCondition();
    }
    
    onDraw() {
        this.drawSkeleton();
    }
    
    onResults(results) {
        this.latestResults = results;
    }

    _setupPhysics() {
        const { Engine, Render, Runner, World, Bodies } = Matter;
        this.matterEngine = Engine.create({ enableSleeping: true });
        this.matterRunner = Runner.create();
        this.matterRenderer = Render.create({
            element: this.ui.gameCanvasContainer,
            engine: this.matterEngine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent'
            }
        });

        const w = window.innerWidth, h = window.innerHeight;
        const wallOptions = { isStatic: true, render: { visible: false } };
        World.add(this.matterEngine.world, [
            Bodies.rectangle(w / 2, h + 30, w, 60, wallOptions),
            Bodies.rectangle(-30, h / 2, 60, h, wallOptions),
            Bodies.rectangle(w + 30, h / 2, 60, h, wallOptions)
        ]);

        this.platform = Bodies.rectangle(w / 2, h - 250, 400, 20, {
            isStatic: true,
            render: { fillStyle: '#e0e0e0' },
            label: 'platform'
        });
        World.add(this.matterEngine.world, this.platform);

        Render.run(this.matterRenderer);
        Runner.run(this.matterRunner, this.matterEngine);
    }
    
    drawSkeleton() {
        if (!this.skeletonCtx || !this.latestResults) return;
        
        const w = this.skeletonCanvas.width;
        const h = this.skeletonCanvas.height;
        this.skeletonCtx.clearRect(0, 0, w, h);
        
        if (this.latestResults.image) {
            this.skeletonCtx.drawImage(this.latestResults.image, 0, 0, w, h);
        }

        const hands = [];
        if (this.latestResults.multiHandLandmarks) hands.push(...this.latestResults.multiHandLandmarks);
        if (this.latestResults.leftHandLandmarks) hands.push(this.latestResults.leftHandLandmarks);
        if (this.latestResults.rightHandLandmarks) hands.push(this.latestResults.rightHandLandmarks);

        for (const landmarks of hands) {
            if (landmarks) {
                drawConnectors(this.skeletonCtx, landmarks, HAND_CONNECTIONS, { color: '#FFFFFF', lineWidth: 2 });
                drawLandmarks(this.skeletonCtx, landmarks, { color: '#FFD700', radius: 4 });
            }
        }
    }

    resetGame() {
        this.isGameOver = false;
        this.updateScore(0);
        this.ui.messageElement.style.display = 'none';

        if (!this.matterRunner || !this.matterEngine) return;
        
        this.matterRunner.enabled = true;
        
        const allBodies = Matter.Composite.allBodies(this.matterEngine.world);
        allBodies.forEach(body => {
            if (!body.isStatic) {
                Matter.Composite.remove(this.matterEngine.world, body);
            }
        });

        const cupWidth = 50, cupHeight = 70;
        const startY = this.platform.position.y - 10 - (cupHeight / 2);
        const startX = this.platform.position.x - (2 * cupWidth + 2 * 10);
        const cupOptions = {
            density: 0.005,
            friction: 0.8,
            restitution: 0.1,
            label: 'cup',
            sleepThreshold: 60
        };

        for (let i = 0; i < 5; i++) {
            const cup = Matter.Bodies.rectangle(startX + i * (cupWidth + 10), startY, cupWidth, cupHeight, {
                ...cupOptions,
                render: { fillStyle: '#4287f5' }
            });
            cup.isScored = false;
            Matter.World.add(this.matterEngine.world, cup);
        }
    }

    checkCollisions() {
        if (!this.matterEngine) return;
        const cups = Matter.Composite.allBodies(this.matterEngine.world).filter(b => b.label === 'cup');

        for (const pointer of this.motionEngine.pointers) {
            if (!pointer.isVisible) continue;

            const handPos = {
                x: (1 - pointer.x) * window.innerWidth,
                y: pointer.y * window.innerHeight,
                radius: 15
            };

            for (const cup of cups) {
                if (Math.hypot(handPos.x - cup.position.x, handPos.y - cup.position.y) < handPos.radius + (cup.bounds.max.x - cup.bounds.min.x) / 2) {
                    const direction = Matter.Vector.normalise(Matter.Vector.sub(cup.position, handPos));
                    Matter.Body.setVelocity(cup, {
                        x: direction.x * 15,
                        y: (direction.y || -1) * 15
                    });
                    Matter.Sleeping.set(cup, false);
                }
            }
        }
    }

    checkWinCondition() {
        if (this.isGameOver || !this.matterEngine) return;

        let currentScore = 0;
        const platformTop = this.platform.position.y - 10;
        const cups = Matter.Composite.allBodies(this.matterEngine.world).filter(b => b.label === 'cup');

        cups.forEach(cup => {
            if (!cup.isScored && (Math.abs(cup.angle) > Math.PI / 3 || cup.position.y > platformTop + 50)) {
                cup.isScored = true;
                cup.render.fillStyle = '#888888';
            }
            if (cup.isScored) {
                currentScore += 100;
            }
        });

        this.updateScore(currentScore);

        if (this.score >= 500) {
            this.isGameOver = true;
            this.ui.messageElement.textContent = "You Win!";
            this.ui.messageElement.style.display = 'block';
            this.matterRunner.enabled = false;
        }
    }

    updateScore(newScore) {
        if (this.score !== newScore) {
            this.score = newScore;
            this.ui.scoreElement.textContent = `Score: ${this.score}`;
        }
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\energy-flow-scene.js 
// src/games/energy-flow-scene.js
import { BaseScene } from '../core/base-scene.js';

// 將 PointSmoother 移出 class，因為佢係一個獨立嘅工具
class PointSmoother {
    constructor(smoothingFactor = 0.8) {
        this.smoothingFactor = smoothingFactor;
        this.point = null;
    }
    update(rawPoint) {
        if (!rawPoint) {
            this.point = null;
            return null;
        }
        if (!this.point) {
            this.point = { ...rawPoint };
        } else {
            this.point.x = this.smoothingFactor * this.point.x + (1 - this.smoothingFactor) * rawPoint.x;
            this.point.y = this.smoothingFactor * this.point.y + (1 - this.smoothingFactor) * rawPoint.y;
        }
        return this.point;
    }
    reset() {
        this.point = null;
    }
}

export class EnergyFlowScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        this.handSmoother = new PointSmoother(0.85);

        this.gameState = 'playing';
        this.hand = {
            pos: { x: -100, y: -100 },
            prevPos: { x: -100, y: -100 },
            speed: 0,
            isVisible: false
        };
        this.orb = {
            pos: { x: 0, y: 0 },
            vel: { x: 0, y: 0 },
            radius: 20,
            isAttached: false
        };
        this.path = [];
        this.progress = 0;
        this.config = {
            maxSpeed: 15,
            attachDistance: 80,
            springConstant: 0.04,
            damping: 0.75,
            pathTolerance: 50
        };

        // 計時器管理
        this.reattachCooldownTimer = null;
        this.initialMessageTimer = null;
    }

    renderHTML() {
        return `
            <style>
                .ef-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #0c0c1e; font-family: 'Segoe UI', sans-serif; }
                .ef-scene #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .ef-scene #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; color: white; pointer-events: none; display: flex; flex-direction: column; align-items: center; }
                .ef-scene #progress-bar-container { width: 50%; height: 10px; background-color: rgba(255,255,255,0.2); margin-top: 20px; border-radius: 5px; }
                .ef-scene #progress-bar { width: 0%; height: 100%; background-color: #00f2ff; border-radius: 5px; transition: width 0.2s linear; }
                .ef-scene #message-container { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
                .ef-scene #message { font-size: 3em; font-weight: bold; text-shadow: 0 0 10px #00f2ff; }
                .ef-scene #restart-button { padding: 15px 30px; font-size: 1.5em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; pointer-events: auto; display: none; }
            </style>
            <div class="ef-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="game-canvas"></canvas>
                <div id="game-ui">
                    <div id="progress-bar-container"><div id="progress-bar"></div></div>
                    <div id="message-container">
                        <h2 id="message"></h2>
                        <button id="restart-button" data-motion-activatable>Restart</button>
                    </div>
                </div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('pose');
        this.motionEngine.setPointerHand('left');
        this.motionEngine.outputCanvas.style.display = 'block';

        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.ui.progressBar = document.getElementById('progress-bar');
        this.ui.messageEl = document.getElementById('message');
        this.ui.restartBtn = document.getElementById('restart-button');

        this.addManagedEventListener(this.ui.restartBtn, 'click', () => this.startGame());
        this.listenToMotionResults();

        this.startGame();
    }

    onDestroy() {
        // **徹底清理計時器**
        if (this.reattachCooldownTimer) clearTimeout(this.reattachCooldownTimer);
        if (this.initialMessageTimer) clearTimeout(this.initialMessageTimer);
        this.reattachCooldownTimer = null;
        this.initialMessageTimer = null;
        
        // 還原 motion engine 設置
        this.motionEngine.setPointerHand('right'); // 還原預設值
        
        // 清理引用
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        console.log("[EnergyFlowScene] Timers cleared and resources destroyed.");
    }
    
    onUpdate() {
        if (this.gameState !== 'playing') return;
        
        this.updateHandPosition();
        
        let closestDist = Infinity;
        let closestSegmentIndex = 0;
        
        // 找到 orb 離路徑最近嘅點
        for (let i = 0; i < this.path.length; i++) {
            const dist = Math.hypot(this.orb.pos.x - this.path[i].x, this.orb.pos.y - this.path[i].y);
            if (dist < closestDist) {
                closestDist = dist;
                closestSegmentIndex = i;
            }
        }

        const distToHand = Math.hypot(this.hand.pos.x - this.orb.pos.x, this.hand.pos.y - this.orb.pos.y);
        const canReattach = this.reattachCooldownTimer === null;

        if (this.orb.isAttached) {
            // 脫離條件
            if (this.hand.speed > this.config.maxSpeed || !this.hand.isVisible || closestDist > this.config.pathTolerance * 1.5) {
                this.orb.isAttached = false;
                // 俾個初始速度
                this.orb.vel.x = (this.hand.pos.x - this.hand.prevPos.x) * 0.5;
                this.orb.vel.y = (this.hand.pos.y - this.hand.prevPos.y) * 0.5;
                // 設置冷卻，防止立即重新吸附
                this.reattachCooldownTimer = setTimeout(() => { this.reattachCooldownTimer = null; }, 500);
            }
        } else {
            // 吸附條件
            if (canReattach && this.hand.isVisible && this.hand.speed < 5 && distToHand < this.config.attachDistance && closestDist < this.config.pathTolerance) {
                this.orb.isAttached = true;
            } else if (this.hand.isVisible && distToHand < this.config.attachDistance) {
                // 如果手喺附近，但未吸附，俾一個微弱嘅牽引力
                const pullForce = 0.2;
                const pullX = (this.orb.pos.x - this.hand.pos.x) / distToHand;
                const pullY = (this.orb.pos.y - this.hand.pos.y) / distToHand;
                this.orb.vel.x += pullX * pullForce * this.hand.speed;
                this.orb.vel.y += pullY * pullForce * this.hand.speed;
            }
        }

        // 更新 orb 物理狀態
        if (this.orb.isAttached) {
            // 彈簧效果
            const forceX = (this.hand.pos.x - this.orb.pos.x) * this.config.springConstant;
            const forceY = (this.hand.pos.y - this.orb.pos.y) * this.config.springConstant;
            this.orb.vel.x = (this.orb.vel.x + forceX) * this.config.damping;
            this.orb.vel.y = (this.orb.vel.y + forceY) * this.config.damping;
        } else {
            // 自由滑動時嘅阻力
            this.orb.vel.x *= 0.98;
            this.orb.vel.y *= 0.98;
        }
        
        this.orb.pos.x += this.orb.vel.x;
        this.orb.pos.y += this.orb.vel.y;

        // 邊界碰撞
        const r = this.orb.radius;
        if (this.orb.pos.x < r) { this.orb.pos.x = r; this.orb.vel.x *= -0.8; }
        if (this.orb.pos.x > this.canvas.width - r) { this.orb.pos.x = this.canvas.width - r; this.orb.vel.x *= -0.8; }
        if (this.orb.pos.y < r) { this.orb.pos.y = r; this.orb.vel.y *= -0.8; }
        if (this.orb.pos.y > this.canvas.height - r) { this.orb.pos.y = this.canvas.height - r; this.orb.vel.y *= -0.8; }

        // 更新進度
        if (this.orb.isAttached && closestDist < this.config.pathTolerance) {
            const newProgress = (closestSegmentIndex / (this.path.length - 1)) * 100;
            if (newProgress > this.progress) {
                this.progress = newProgress;
            }
        }

        // 勝利條件
        if (this.progress >= 100) {
            this.gameState = 'win';
            this.ui.messageEl.textContent = 'Flow Complete!';
            this.ui.restartBtn.style.display = 'block';
        }
    }
    
    onDraw() {
        if (!this.ctx) return;
        
        // 清理畫布
        this.ctx.fillStyle = '#0c0c1e';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 繪製骨架 (半透明)
        if (this.latestResults && this.latestResults.poseLandmarks) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.2;
            this.ctx.translate(this.canvas.width, 0);
            this.ctx.scale(-1, 1);
            drawConnectors(this.ctx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, { color: 'white', lineWidth: 1 });
            this.ctx.restore();
        }

        // 繪製路徑
        this.ctx.strokeStyle = 'rgba(255, 255, 255, .1)';
        this.ctx.lineWidth = this.config.pathTolerance * 2;
        this.ctx.lineCap = 'round';
        this.ctx.beginPath();
        this.ctx.moveTo(this.path[0].x, this.path[0].y);
        for (let i = 1; i < this.path.length; i++) this.ctx.lineTo(this.path[i].x, this.path[i].y);
        this.ctx.stroke();
        
        this.ctx.strokeStyle = 'rgba(0, 242, 255, .4)';
        this.ctx.lineWidth = 4;
        this.ctx.stroke();

        // 繪製手部吸附範圍
        if (this.hand.isVisible) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, .1)';
            this.ctx.beginPath();
            this.ctx.arc(this.hand.pos.x, this.hand.pos.y, this.config.attachDistance, 0, 2 * Math.PI);
            this.ctx.fill();
        }

        // 繪製能量球
        const orbColor = this.orb.isAttached ? '#00f2ff' : '#ff4d84';
        const glowColor = this.orb.isAttached ? 'rgba(0, 242, 255, .5)' : 'rgba(255, 77, 132, .5)';
        this.ctx.shadowColor = glowColor;
        this.ctx.shadowBlur = 30;
        this.ctx.fillStyle = orbColor;
        this.ctx.beginPath();
        this.ctx.arc(this.orb.pos.x, this.orb.pos.y, this.orb.radius, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;

        // 更新 UI
        this.ui.progressBar.style.width = `${this.progress}%`;
    }

    startGame() {
        if (this.reattachCooldownTimer) clearTimeout(this.reattachCooldownTimer);
        if (this.initialMessageTimer) clearTimeout(this.initialMessageTimer);

        this.gameState = 'playing';
        this.hand = { pos: { x: -100, y: -100 }, prevPos: { x: -100, y: -100 }, speed: 0, isVisible: false };
        this.handSmoother.reset();
        
        this.definePath();
        this.orb = { pos: { ...this.path[0] }, vel: { x: 0, y: 0 }, radius: 20, isAttached: false };
        this.progress = 0;
        
        this.ui.messageEl.textContent = 'Guide the orb along the path';
        this.ui.restartBtn.style.display = 'none';
        
        this.initialMessageTimer = setTimeout(() => {
            if (this.gameState === 'playing') {
                this.ui.messageEl.textContent = '';
            }
        }, 3000);
    }
    
    definePath() {
        const w = this.canvas.width, h = this.canvas.height;
        const segments = 200;
        this.path = [];
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = w * 0.1 + t * w * 0.8;
            const y = h / 2 + Math.sin(t * Math.PI * 2) * h * 0.25;
            this.path.push({ x, y });
        }
    }

    updateHandPosition() {
        if (this.gameState !== 'playing' || !this.latestResults || !this.latestResults.poseLandmarks) {
            this.hand.isVisible = false;
            return;
        }

        const rawPoint = window.getPalmCenterFromPose(this.latestResults.poseLandmarks, 'left');
        const smoothedPoint = this.handSmoother.update(rawPoint);

        if (smoothedPoint) {
            this.hand.isVisible = true;
            this.hand.prevPos = { ...this.hand.pos };
            this.hand.pos.x = (1 - smoothedPoint.x) * this.canvas.width;
            this.hand.pos.y = smoothedPoint.y * this.canvas.height;
            this.hand.speed = Math.hypot(this.hand.pos.x - this.hand.prevPos.x, this.hand.pos.y - this.hand.prevPos.y);
        } else {
            this.hand.isVisible = false;
            this.hand.speed = 0;
        }
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\joint-painter-scene.js 
// src/games/joint-painter-scene.js
import { BaseScene } from '../core/base-scene.js';

class PointSmoother {
    constructor(smoothingFactor = 0.7) {
        this.smoothingFactor = smoothingFactor;
        this.point = null;
    }
    update(rawPoint) {
        if (!rawPoint) {
            this.point = null;
            return null;
        }
        if (!this.point) {
            this.point = { ...rawPoint };
        } else {
            this.point.x = this.smoothingFactor * this.point.x + (1 - this.smoothingFactor) * rawPoint.x;
            this.point.y = this.smoothingFactor * this.point.y + (1 - this.smoothingFactor) * rawPoint.y;
        }
        return this.point;
    }
    reset() {
        this.point = null;
    }
}

export class JointPainterScene extends BaseScene {
    constructor() {
        super();
        this.drawingCtx = null;
        this.skeletonCtx = null;
        this.brushHand = 'left';
        this.lastBrushPosition = null;
        this.isDrawing = false;
        this.brushSmoother = new PointSmoother(0.6);
    }

    renderHTML() {
        return `
            <style>
                .jp-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #1a1d22; }
                .jp-scene #drawing-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .jp-scene #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; opacity: 0.5; transform: scaleX(-1); }
                .jp-scene #controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 4; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px; display: flex; flex-wrap: wrap; gap: 10px; pointer-events: auto;}
                .jp-scene .control-btn { padding: 10px 15px; font-size: 1em; background-color: #444; color: white; border: 2px solid transparent; border-radius: 8px; cursor: pointer; }
                .jp-scene .control-btn.active { border-color: #ffd700; background-color: #666; }
                .jp-scene #clear-btn { background-color: #c0392b; }
            </style>
            <div class="jp-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="drawing-canvas"></canvas>
                <canvas id="skeleton-canvas"></canvas>
                <div id="controls">
                    <button id="brush-left-hand" class="control-btn active" data-motion-activatable>左手</button>
                    <button id="brush-right-hand" class="control-btn" data-motion-activatable>右手</button>
                    <button id="clear-btn" class="control-btn" data-motion-activatable>清除畫布</button>
                </div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('pose');
        this.motionEngine.setPointerHand('left'); // 雖然唔用指針，但設置一下冇壞處
        this.motionEngine.outputCanvas.style.display = 'none'; // 呢個 game 唔需要顯示 motion engine 指針

        const drawingCanvas = document.getElementById('drawing-canvas');
        const skeletonCanvas = document.getElementById('skeleton-canvas');
        
        this.drawingCtx = drawingCanvas.getContext('2d');
        this.skeletonCtx = skeletonCanvas.getContext('2d');

        drawingCanvas.width = skeletonCanvas.width = window.innerWidth;
        drawingCanvas.height = skeletonCanvas.height = window.innerHeight;

        this._bindEvents();
        this.listenToMotionResults();
    }
    
    onDestroy() {
        this.drawingCtx = null;
        this.skeletonCtx = null;
        this.lastBrushPosition = null;
        console.log("[JointPainterScene] Canvases and state cleared.");
    }
    
    onUpdate() {
        this.updateDrawingState();
    }
    
    onDraw() {
        this.drawSkeletonAndBrush();
    }

    _bindEvents() {
        const setBrush = (hand, buttonId) => {
            this.brushHand = hand;
            this.container.querySelectorAll('#controls .control-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(buttonId).classList.add('active');
            this.brushSmoother.reset();
            this.isDrawing = false;
            this.lastBrushPosition = null;
        };

        this.addManagedEventListener(document.getElementById('brush-left-hand'), 'click', () => setBrush('left', 'brush-left-hand'));
        this.addManagedEventListener(document.getElementById('brush-right-hand'), 'click', () => setBrush('right', 'brush-right-hand'));
        this.addManagedEventListener(document.getElementById('clear-btn'), 'click', () => {
            if (this.drawingCtx) {
                this.drawingCtx.clearRect(0, 0, this.drawingCtx.canvas.width, this.drawingCtx.canvas.height);
            }
        });
    }

    updateDrawingState() {
        if (!this.latestResults || !this.latestResults.poseLandmarks) {
            this.isDrawing = false;
            this.lastBrushPosition = null;
            return;
        }

        const rawBrushPoint = window.getPalmCenterFromPose(this.latestResults.poseLandmarks, this.brushHand);
        const smoothedPoint = this.brushSmoother.update(rawBrushPoint);

        if (smoothedPoint) {
            const w = this.drawingCtx.canvas.width;
            const h = this.drawingCtx.canvas.height;
            const currentPos = {
                x: (1 - smoothedPoint.x) * w,
                y: smoothedPoint.y * h
            };

            if (!this.isDrawing) {
                this.isDrawing = true;
            } else {
                // 只有喺 isDrawing 為 true 時先畫線
                this.drawingCtx.strokeStyle = 'cyan';
                this.drawingCtx.lineWidth = 10;
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.lineJoin = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(this.lastBrushPosition.x, this.lastBrushPosition.y);
                this.drawingCtx.lineTo(currentPos.x, currentPos.y);
                this.drawingCtx.stroke();
            }
            this.lastBrushPosition = currentPos;
        } else {
            this.isDrawing = false;
            this.lastBrushPosition = null;
        }
    }

    drawSkeletonAndBrush() {
        if (!this.skeletonCtx) return;

        const w = this.skeletonCtx.canvas.width;
        const h = this.skeletonCtx.canvas.height;
        this.skeletonCtx.clearRect(0, 0, w, h);

        if (this.latestResults && this.latestResults.poseLandmarks) {
            // 繪製骨架
            drawConnectors(this.skeletonCtx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, { color: 'white', lineWidth: 2 });
            
            // 繪製筆刷位置
            const rawBrushPoint = window.getPalmCenterFromPose(this.latestResults.poseLandmarks, this.brushHand);
            if (rawBrushPoint) {
                // 注意：這裡用 smoothedPoint 嚟畫，但 smoother 喺 updateDrawingState 已經更新過
                const smoothedPoint = this.brushSmoother.update(rawBrushPoint);
                if (smoothedPoint) {
                    this.skeletonCtx.fillStyle = 'yellow';
                    this.skeletonCtx.beginPath();
                    this.skeletonCtx.arc(smoothedPoint.x * w, smoothedPoint.y * h, 15, 0, 2 * Math.PI);
                    this.skeletonCtx.fill();
                }
            }
        }
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\magic-guardian-scene.js 
// src/games/magic-guardian-scene.js
import { BaseScene } from '../core/base-scene.js';

class GestureRecognizer {
    static getGesture(landmarks) {
        if (!landmarks) return 'none';
        try {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            const isFist = this.distance(indexTip, wrist) < this.distance(landmarks[5], wrist) &&
                           this.distance(middleTip, wrist) < this.distance(landmarks[9], wrist) &&
                           this.distance(ringTip, wrist) < this.distance(landmarks[13], wrist) &&
                           this.distance(pinkyTip, wrist) < this.distance(landmarks[17], wrist);

            if (isFist) return 'fist';

            const isFive = this.distance(thumbTip, pinkyTip) > 0.15 && // 拇指同尾指距離夠遠
                           this.distance(indexTip, wrist) > this.distance(landmarks[5], wrist); // 食指伸直

            if (isFive) return 'open';

            return 'none';
        } catch (e) {
            return 'none';
        }
    }
    static distance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }
}

export class MagicGuardianScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.ui = {};

        this.player = {
            bodyHitbox: { x: 0, y: 0, rx: 0, ry: 0 },
            leftHand: { x: -100, y: -100, radius: 65, gesture: 'none' },
            rightHand: { x: -100, y: -100, radius: 65, gesture: 'none' }
        };

        this.score = 0;
        this.lives = 5;
        this.isGameOver = false;

        this.fireballs = [];
        this.magicOrbs = [];
        this.particles = [];
        this.spawnInterval = null;
        this.flashTimeout = null;
    }

    renderHTML() {
        return `
            <style>
                .mg-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #112; }
                .mg-scene #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; transform: scaleX(-1); }
                .mg-scene #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; color: white; text-shadow: 2px 2px 4px black; pointer-events: none; }
                .mg-scene #game-stats { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; font-size: 2em; font-weight: bold; }
                .mg-scene #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 10; display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
                .mg-scene #game-over-screen h2 { font-size: 5em; margin: 0; color: #ff4d4d; }
                .mg-scene #game-over-screen p { font-size: 1.5em; }
                .mg-scene #restart-button { padding: 15px 30px; font-size: 1.5em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; }
                .mg-scene .screen-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; opacity: 0; }
                .mg-scene .hit-flash { background-color: red; animation: flash 0.3s ease-out; }
                @keyframes flash { from { opacity: 0.7; } to { opacity: 0; } }
            </style>
            <div class="mg-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="output-canvas"></canvas>
                <div id="ui-layer">
                    <div id="game-stats">
                        <div id="score">Score: 0</div>
                        <div id="lives">Lives: ❤️❤️❤️❤️❤️</div>
                    </div>
                </div>
                <div id="game-over-screen">
                    <h2>GAME OVER</h2>
                    <p id="final-score"></p>
                    <button id="restart-button" data-motion-activatable>Restart Game</button>
                </div>
                <div id="screen-flash" class="screen-flash"></div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'none'; // 我哋用自己嘅 canvas 畫所有嘢

        this.canvas = document.getElementById('output-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.ui = {
            scoreEl: document.getElementById('score'),
            livesEl: document.getElementById('lives'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScoreEl: document.getElementById('final-score'),
            restartBtn: document.getElementById('restart-button'),
            screenFlashEl: document.getElementById('screen-flash')
        };
        
        this.addManagedEventListener(this.ui.restartBtn, 'click', () => this.startGame());
        this.listenToMotionResults();
        
        this.startGame();
    }

    onDestroy() {
        if (this.spawnInterval) clearInterval(this.spawnInterval);
        if (this.flashTimeout) clearTimeout(this.flashTimeout);
        this.spawnInterval = null;
        this.flashTimeout = null;

        // 清空所有動態數組
        this.fireballs = [];
        this.magicOrbs = [];
        this.particles = [];
        
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        console.log("[MagicGuardianScene] Timers and game objects cleared.");
    }

    onUpdate() {
        if (this.isGameOver) return;
        this.updatePlayerState();
        this.updateGameObjects();
        this.checkCollisions();
    }

    onDraw() {
        if (!this.ctx) return;
        const w = this.canvas.width, h = this.canvas.height;
        
        // 繪製背景 / 攝像頭畫面
        this.ctx.save();
        if (this.latestResults && this.latestResults.image) {
            this.ctx.drawImage(this.latestResults.image, 0, 0, w, h);
        } else {
            this.ctx.fillStyle = '#112';
            this.ctx.fillRect(0, 0, w, h);
        }
        this.ctx.restore();

        // 繪製遊戲元素
        this.drawGameElements();
    }

    startGame() {
        this.score = 0;
        this.lives = 5;
        this.isGameOver = false;
        this.fireballs = [];
        this.magicOrbs = [];
        this.particles = [];
        
        this.updateUI();
        this.ui.gameOverScreen.style.display = 'none';

        if (this.spawnInterval) clearInterval(this.spawnInterval);
        this.spawnInterval = setInterval(() => {
            if (this.isGameOver) return;
            this.spawnFireball();
            if (Math.random() < 0.4) this.spawnMagicOrb();
        }, 1200);
    }

    updatePlayerState() {
        if (!this.latestResults) return;
        
        const w = this.canvas.width, h = this.canvas.height;
        const getScreenCoords = (p) => (p ? { x: (1 - p.x) * w, y: p.y * h } : null);

        // 更新身體 Hitbox
        if (this.latestResults.poseLandmarks) {
            const [ls, rs, lh, rh] = [11, 12, 23, 24].map(i => this.latestResults.poseLandmarks[i]);
            if (ls && rs && lh && rh && ls.visibility > 0.6 && rh.visibility > 0.6) {
                const lsp = getScreenCoords(ls), rsp = getScreenCoords(rs);
                const lhp = getScreenCoords(lh), rhp = getScreenCoords(rh);
                this.player.bodyHitbox.x = (lsp.x + rsp.x) / 2;
                this.player.bodyHitbox.y = (lsp.y + lhp.y) / 2;
                this.player.bodyHitbox.rx = Math.abs(lsp.x - rsp.x) / 2 * 0.8;
                this.player.bodyHitbox.ry = Math.abs(lsp.y - lhp.y) / 2 * 0.9;
            }
        }

        // 更新手部狀態
        const updateHand = (handName, landmarks) => {
            const hand = this.player[handName];
            hand.gesture = GestureRecognizer.getGesture(landmarks);
            if (landmarks) {
                const [wrist, indexMCP, pinkyMCP] = [0, 5, 17].map(i => landmarks[i]);
                if (wrist && indexMCP && pinkyMCP) {
                    const palmCenterX = (wrist.x + indexMCP.x + pinkyMCP.x) / 3;
                    const palmCenterY = (wrist.y + indexMCP.y + pinkyMCP.y) / 3;
                    const screenPos = getScreenCoords({ x: palmCenterX, y: palmCenterY });
                    if (screenPos) {
                        hand.x = screenPos.x;
                        hand.y = screenPos.y;
                    }
                }
            }
        };
        updateHand('leftHand', this.latestResults.leftHandLandmarks);
        updateHand('rightHand', this.latestResults.rightHandLandmarks);
    }
    
    updateGameObjects() {
        const move = (obj) => { obj.x += obj.vx; obj.y += obj.vy; };
        this.fireballs.forEach(move);
        this.magicOrbs.forEach(move);
        this.particles.forEach(p => { move(p); p.life--; p.radius *= 0.98; });

        // 過濾掉屏幕外或已死亡嘅物件
        const isOnScreen = (o) => o.x > -50 && o.x < this.canvas.width + 50 && o.y > -50 && o.y < this.canvas.height + 50;
        this.fireballs = this.fireballs.filter(isOnScreen);
        this.magicOrbs = this.magicOrbs.filter(isOnScreen);
        this.particles = this.particles.filter(p => p.life > 0);
    }
    
    checkCollisions() {
        const isCircleColliding = (c1, c2) => Math.hypot(c1.x - c2.x, c1.y - c2.y) < c1.radius + c2.radius;
        const isEllipseColliding = (ellipse, circle) => {
            const dx = circle.x - ellipse.x;
            const dy = circle.y - ellipse.y;
            return ((dx / (ellipse.rx + circle.radius)) ** 2) + ((dy / (ellipse.ry + circle.radius)) ** 2) < 1;
        };

        // 檢查火球
        for (let i = this.fireballs.length - 1; i >= 0; i--) {
            const fireball = this.fireballs[i];
            const leftDeflected = this.player.leftHand.gesture === 'fist' && isCircleColliding(this.player.leftHand, fireball);
            const rightDeflected = this.player.rightHand.gesture === 'fist' && isCircleColliding(this.player.rightHand, fireball);

            if (leftDeflected || rightDeflected) {
                this.score += 20;
                this.createExplosion(fireball.x, fireball.y, 'orange');
                this.fireballs.splice(i, 1);
                this.updateUI();
            } else if (isEllipseColliding(this.player.bodyHitbox, fireball)) {
                this.lives--;
                this.createExplosion(fireball.x, fireball.y, 'red');
                this.fireballs.splice(i, 1);
                this.updateUI();
                this.triggerHitFlash();
                if (this.lives <= 0) {
                    this.gameOver();
                    break;
                }
            }
        }

        // 檢查魔法球
        for (let i = this.magicOrbs.length - 1; i >= 0; i--) {
            const orb = this.magicOrbs[i];
            const leftCaught = this.player.leftHand.gesture === 'open' && isCircleColliding(this.player.leftHand, orb);
            const rightCaught = this.player.rightHand.gesture === 'open' && isCircleColliding(this.player.rightHand, orb);

            if (leftCaught || rightCaught) {
                this.score += 100;
                this.createExplosion(orb.x, orb.y, 'cyan');
                this.magicOrbs.splice(i, 1);
                this.updateUI();
            }
        }
    }

    drawGameElements() {
        const { bodyHitbox, leftHand, rightHand } = this.player;

        // 身體護盾
        this.ctx.fillStyle = 'rgba(0, 255, 255, .2)';
        this.ctx.strokeStyle = 'rgba(0, 255, 255, .7)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.ellipse(bodyHitbox.x, bodyHitbox.y, bodyHitbox.rx, bodyHitbox.ry, 0, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.stroke();

        // 雙手
        this.drawHandCircle(this.ctx, leftHand);
        this.drawHandCircle(this.ctx, rightHand);

        // 飛行物
        this.fireballs.forEach(f => { this.ctx.fillStyle = 'orange'; this.ctx.beginPath(); this.ctx.arc(f.x, f.y, f.radius, 0, 2 * Math.PI); this.ctx.fill(); });
        this.magicOrbs.forEach(o => { this.ctx.fillStyle = 'cyan'; this.ctx.beginPath(); this.ctx.arc(o.x, o.y, o.radius, 0, 2 * Math.PI); this.ctx.fill(); });
        
        // 粒子效果
        this.particles.forEach(p => { this.ctx.fillStyle = p.color; this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI); this.ctx.fill(); });
    }

    drawHandCircle(ctx, hand) {
        let color = 'rgba(100, 100, 100, .5)';
        let glow = 'transparent';
        let stroke = 'rgba(200, 200, 200, .7)';
        
        if (hand.gesture === 'open') {
            color = 'rgba(0, 176, 255, .8)';
            glow = '#00B0FF';
        } else if (hand.gesture === 'fist') {
            color = 'rgba(255, 100, 0, .8)';
            glow = '#FF8C00';
            stroke = '#FFD700';
        }

        ctx.shadowColor = glow;
        ctx.shadowBlur = (hand.gesture !== 'none') ? 20 : 0;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(hand.x, hand.y, hand.radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        if (hand.gesture === 'fist') {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 4;
            ctx.stroke();
        }
    }

    spawnObject(type) {
        const w = this.canvas.width, h = this.canvas.height;
        const radius = type === 'fireball' ? 25 : 30;
        let x, y;
        const side = Math.floor(Math.random() * 3); // 0: left, 1: right, 2: top
        switch (side) {
            case 0: x = -radius; y = Math.random() * h * 0.9; break;
            case 1: x = w + radius; y = Math.random() * h * 0.9; break;
            case 2: x = Math.random() * w; y = -radius; break;
        }

        const targetX = w / 2 + (Math.random() - 0.5) * 400;
        const targetY = h / 2 + (Math.random() - 0.5) * 300;
        const angle = Math.atan2(targetY - y, targetX - x);
        const speed = type === 'fireball' ? (2 + Math.random() * 2) : (1.5 + Math.random());
        
        return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius, type };
    }

    spawnFireball() { this.fireballs.push(this.spawnObject('fireball')); }
    spawnMagicOrb() { this.magicOrbs.push(this.spawnObject('magicOrb')); }

    createExplosion(x, y, color, count = 20) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            this.particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: 2 + Math.random() * 3,
                life: 30 + Math.random() * 30,
                color: color
            });
        }
    }

    triggerHitFlash() {
        if (this.flashTimeout) clearTimeout(this.flashTimeout);
        this.ui.screenFlashEl.className = 'screen-flash hit-flash';
        this.flashTimeout = setTimeout(() => {
            this.ui.screenFlashEl.className = 'screen-flash';
        }, 300);
    }
    
    gameOver() {
        this.isGameOver = true;
        clearInterval(this.spawnInterval);
        this.spawnInterval = null;
        this.ui.finalScoreEl.textContent = `Your Score: ${this.score}`;
        this.ui.gameOverScreen.style.display = 'flex';
    }

    updateUI() {
        this.ui.scoreEl.textContent = `Score: ${this.score}`;
        this.ui.livesEl.textContent = `Lives: ${'❤️'.repeat(Math.max(0, this.lives))}`;
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\motion-beat-scene.js 
// src/games/motion-beat-scene.js
import { BaseScene } from '../core/base-scene.js';

class PointSmoother {
    constructor(smoothingFactor = 0.8) {
        this.smoothingFactor = smoothingFactor;
        this.point = null;
    }
    update(rawPoint) {
        if (!rawPoint) {
            // 如果沒有新數據，讓點保持在最後位置一段時間後消失
            // (目前嘅邏輯係立即消失)
            return this.point; 
        }
        if (!this.point) {
            this.point = { ...rawPoint };
        } else {
            this.point.x = this.smoothingFactor * this.point.x + (1 - this.smoothingFactor) * rawPoint.x;
            this.point.y = this.smoothingFactor * this.point.y + (1 - this.smoothingFactor) * rawPoint.y;
        }
        return this.point;
    }
    reset() {
        this.point = null;
    }
}

export class MotionBeatScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.ui = {};

        this.limbs = {
            LEFT_HAND:  { name: '左手', poseIndex: [15, 17, 19], x: 0.25, y: 0.4, color: '#3498db', radius: 50 },
            RIGHT_HAND: { name: '右手', poseIndex: [16, 18, 20], x: 0.75, y: 0.4, color: '#e74c3c', radius: 50 },
            LEFT_FOOT:  { name: '左腳', poseIndex: [27, 29],    x: 0.35, y: 0.8, color: '#f1c40f', radius: 60 },
            RIGHT_FOOT: { name: '右腳', poseIndex: [28, 30],    x: 0.65, y: 0.8, color: '#2ecc71', radius: 60 }
        };
        this.limbPositions = {};
        this.limbSmoothers = {
            LEFT_HAND: new PointSmoother(0.6),
            RIGHT_HAND: new PointSmoother(0.6),
            LEFT_FOOT: new PointSmoother(0.6),
            RIGHT_FOOT: new PointSmoother(0.6),
        };
        
        this.notes = [];
        this.particles = [];
        this.score = 0;
        this.combo = 0;
        this.spawnInterval = null;
    }

    renderHTML() {
        return `
            <style>
                .mb-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #0c0c1e; }
                .mb-scene #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .mb-scene #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 3; color: white; text-shadow: 2px 2px 4px black; text-align: right; pointer-events: none; }
                .mb-scene #score { font-size: 3em; font-weight: bold; }
                .mb-scene #combo { font-size: 1.5em; color: #ffd700; height: 1.5em; }
            </style>
            <div class="mb-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="game-canvas"></canvas>
                <div id="ui-layer">
                    <div id="score">0</div>
                    <div id="combo"></div>
                </div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('pose');
        this.motionEngine.outputCanvas.style.display = 'none';

        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.ui.scoreEl = document.getElementById('score');
        this.ui.comboEl = document.getElementById('combo');

        for (const key in this.limbs) {
            const limb = this.limbs[key];
            limb.screenX = limb.x * this.canvas.width;
            limb.screenY = limb.y * this.canvas.height;
            this.limbPositions[key] = { x: -1000, y: -1000 };
        }
        
        this.listenToMotionResults();
        this.startGame();
    }

    onDestroy() {
        if (this.spawnInterval) clearInterval(this.spawnInterval);
        this.spawnInterval = null;
        
        this.notes = [];
        this.particles = [];
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        console.log("[MotionBeatScene] Timers and game objects cleared.");
    }

    startGame() {
        this.score = 0;
        this.combo = 0;
        this.notes = [];
        this.particles = [];
        this.updateUI();

        if (this.spawnInterval) clearInterval(this.spawnInterval);
        this.spawnInterval = setInterval(() => this.spawnNote(), 1000);
        
        Object.values(this.limbSmoothers).forEach(smoother => smoother.reset());
    }

    onUpdate() {
        this.updateLimbPositions();

        for (let i = this.notes.length - 1; i >= 0; i--) {
            const note = this.notes[i];
            note.z -= note.speed;

            // 判定區間
            if (note.z < 15 && note.z > -15 && !note.hit && !note.missed) {
                const targetLimb = this.limbs[note.target];
                const limbPos = this.limbPositions[note.target];
                if (Math.hypot(limbPos.x - targetLimb.screenX, limbPos.y - targetLimb.screenY) < targetLimb.radius) {
                    note.hit = true;
                    this.score += 10 + this.combo * 5;
                    this.combo++;
                    this.createExplosion(targetLimb.screenX, targetLimb.screenY, targetLimb.color);
                    this.updateUI();
                }
            }

            // Note 消失
            if (note.z < -20) {
                if (!note.hit) { // Miss
                    this.combo = 0;
                    note.missed = true;
                    this.updateUI();
                }
                this.notes.splice(i, 1);
            }
        }

        // 更新粒子
        this.particles.forEach(p => { p.life--; p.radius *= 0.95; p.x += p.vx; p.y += p.vy; });
        this.particles = this.particles.filter(p => p.life > 0);
    }

    onDraw() {
        if (!this.ctx) return;
        const w = this.canvas.width, h = this.canvas.height;
        this.ctx.clearRect(0, 0, w, h);
        
        // 繪製骨架背景
        if (this.latestResults && this.latestResults.poseLandmarks) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.3;
            this.ctx.translate(w, 0);
            this.ctx.scale(-1, 1);
            drawConnectors(this.ctx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, { color: 'white', lineWidth: 2 });
            this.ctx.restore();
        }

        // 繪製判定區
        for (const key in this.limbs) {
            const limb = this.limbs[key];
            this.ctx.strokeStyle = limb.color;
            this.ctx.lineWidth = 4;
            this.ctx.globalAlpha = 0.5;
            this.ctx.beginPath();
            this.ctx.arc(limb.screenX, limb.screenY, limb.radius, 0, 2 * Math.PI);
            this.ctx.stroke();
            this.ctx.globalAlpha = 1;
        }

        // 繪製玩家嘅四肢位置
        for (const key in this.limbPositions) {
            const limb = this.limbs[key];
            const pos = this.limbPositions[key];
            this.ctx.fillStyle = limb.color;
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, 25, 0, 2 * Math.PI);
            this.ctx.fill();
        }

        // 繪製 Note
        this.notes.sort((a, b) => b.z - a.z); // 由遠到近繪製
        for (const note of this.notes) {
            if (note.hit) continue;
            const targetLimb = this.limbs[note.target];
            const scale = Math.max(0, (100 - note.z) / 100);
            const size = targetLimb.radius * 1.5 * scale;
            
            this.ctx.save();
            this.ctx.translate(targetLimb.screenX, targetLimb.screenY);
            this.ctx.rotate(scale * Math.PI); // 加個旋轉效果
            this.ctx.fillStyle = targetLimb.color;
            this.ctx.globalAlpha = scale * 1.5;
            this.ctx.fillRect(-size / 2, -size / 2, size, size);
            this.ctx.restore();
        }
        
        // 繪製粒子
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life / 40;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI);
            this.ctx.fill();
        });
        this.ctx.globalAlpha = 1;
    }

    updateLimbPositions() {
        if (!this.latestResults || !this.latestResults.poseLandmarks) return;
        
        const w = this.canvas.width, h = this.canvas.height;
        const landmarks = this.latestResults.poseLandmarks;

        for (const key in this.limbs) {
            const config = this.limbs[key];
            let rawPoint = null;

            if (key.includes('HAND')) {
                const [wrist, pinky, index] = config.poseIndex.map(i => landmarks[i]);
                if (wrist && pinky && index && wrist.visibility > 0.5) {
                    rawPoint = {
                        x: (wrist.x + pinky.x + index.x) / 3,
                        y: (wrist.y + pinky.y + index.y) / 3,
                    };
                }
            } else { // FOOT
                const [ankle, heel] = config.poseIndex.map(i => landmarks[i]);
                if (ankle && heel && ankle.visibility > 0.5) {
                    // 估算腳尖位置
                    const vecX = ankle.x - heel.x;
                    const vecY = ankle.y - heel.y;
                    rawPoint = { x: ankle.x + vecX * 0.8, y: ankle.y + vecY * 0.8 };
                }
            }

            const smoothedPoint = this.limbSmoothers[key].update(rawPoint);
            if (smoothedPoint) {
                this.limbPositions[key].x = (1 - smoothedPoint.x) * w;
                this.limbPositions[key].y = smoothedPoint.y * h;
            } else {
                this.limbPositions[key].x = -1000; // 移出畫面
            }
        }
    }
    
    spawnNote() {
        const keys = Object.keys(this.limbs);
        this.notes.push({
            target: keys[Math.floor(Math.random() * keys.length)],
            z: 100, // 初始深度
            speed: 1.2,
            hit: false,
            missed: false
        });
    }

    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 5;
            this.particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: 2 + Math.random() * 3,
                life: 40,
                color
            });
        }
    }

    updateUI() {
        this.ui.scoreEl.textContent = this.score;
        this.ui.comboEl.textContent = this.combo > 1 ? `x${this.combo} Combo!` : '';
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\path-of-balance-scene.js 
// src/games/path-of-balance-scene.js
import { BaseScene } from '../core/base-scene.js';

export class PathOfBalanceScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.ui = {};

        this.gameState = 'idle'; // idle, playing, gameover, win
        this.player = {
            x: 0,
            balanceForce: 0,
            progress: 0,
            width: 60
        };
        this.balanceAngle = 0;
        this.isStepping = false;
        this.pathTotalLength = 2000;
        this.pathOffset = 0;
    }

    renderHTML() {
        return `
            <style>
                .pob-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: linear-gradient(#34495e, #1a2531); font-family: 'Segoe UI', sans-serif; }
                .pob-scene #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .pob-scene #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; text-shadow: 2px 2px 4px black; }
                .pob-scene #message { font-size: 4em; font-weight: bold; }
                .pob-scene #restart-button { padding: 15px 30px; font-size: 1.5em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; pointer-events: auto; display: none; }
                .pob-scene #progress-bar-container { position: absolute; top: 80px; width: 50%; height: 20px; background-color: rgba(0,0,0,0.5); border-radius: 10px; }
                .pob-scene #progress-bar { width: 0%; height: 100%; background-color: #2ecc71; border-radius: 10px; transition: width 0.2s linear; }
            </style>
            <div class="pob-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="game-canvas"></canvas>
                <div id="game-ui">
                    <div id="progress-bar-container"><div id="progress-bar"></div></div>
                    <h2 id="message"></h2>
                    <button id="restart-button" data-motion-activatable>Restart</button>
                </div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('pose');
        this.motionEngine.outputCanvas.style.display = 'block'; // 顯示骨架方便調試
        this.motionEngine.outputCanvas.style.opacity = '0.3';

        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.ui = {
            messageEl: document.getElementById('message'),
            restartBtn: document.getElementById('restart-button'),
            progressBar: document.getElementById('progress-bar')
        };
        
        this.addManagedEventListener(this.ui.restartBtn, 'click', () => this.startGame());
        this.listenToMotionResults();
        
        this.startGame();
    }

    onDestroy() {
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        this.motionEngine.outputCanvas.style.opacity = '1';
        console.log("[PathOfBalanceScene] Destroyed.");
    }

    startGame() {
        this.player = {
            x: this.canvas.width / 2,
            balanceForce: 0,
            progress: 0,
            width: 60
        };
        this.balanceAngle = 0;
        this.isStepping = false;
        this.pathOffset = 0;
        this.gameState = 'playing';
        
        this.ui.messageEl.textContent = 'Keep your balance and step forward!';
        setTimeout(() => { if (this.ui.messageEl) this.ui.messageEl.textContent = ''; }, 3000);
        this.ui.restartBtn.style.display = 'none';
    }

    onUpdate() {
        if (this.gameState !== 'playing') return;

        if (this.latestResults && this.latestResults.poseLandmarks) {
            const landmarks = this.latestResults.poseLandmarks;
            const [leftShoulder, rightShoulder, leftHip, rightHip] = [11, 12, 23, 24].map(i => landmarks[i]);
            
            // 計算平衡
            if (leftShoulder && rightShoulder && leftHip && rightHip && leftShoulder.visibility > 0.5 && rightShoulder.visibility > 0.5) {
                const shoulderMid = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };
                const hipMid = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };
                const angleRad = Math.atan2(shoulderMid.y - hipMid.y, shoulderMid.x - hipMid.x);
                this.balanceAngle = (angleRad * 180 / Math.PI) + 90; // 轉換為角度並校準
                this.player.balanceForce = this.balanceAngle * -0.25; // 角度越大，力越大
            }

            // 檢測踏步
            const [leftKnee, rightKnee] = [25, 26].map(i => landmarks[i]);
            if (leftKnee && rightKnee && leftHip && rightHip && leftKnee.visibility > 0.5 && rightKnee.visibility > 0.5) {
                const hipHeight = (leftHip.y + rightHip.y) / 2;
                const isLeftStepping = leftKnee.y < hipHeight - 0.05; // 膝蓋高過臀部一個閾值
                const isRightStepping = rightKnee.y < hipHeight - 0.05;

                if ((isLeftStepping || isRightStepping) && !this.isStepping) {
                    this.isStepping = true;
                    this.pathOffset += 25; // 每一步前進嘅距離
                    this.player.progress = (this.pathOffset / this.pathTotalLength) * 100;
                } else if (!isLeftStepping && !isRightStepping) {
                    this.isStepping = false; // 雙腳都放下後才能進行下一步
                }
            }
        }
        
        // 更新玩家位置
        this.player.x += this.player.balanceForce;

        // 檢查是否跌落
        const w = this.canvas.width, h = this.canvas.height;
        const horizonY = h * 0.6;
        const pathWidthStart = w * 1.5;
        const pathWidthEnd = w * 0.05;

        const playerVerticalY = h * 0.9;
        const playerProgressRatio = (playerVerticalY - horizonY) / (h - horizonY);
        const pathWidthAtPlayer = pathWidthEnd + (pathWidthStart - pathWidthEnd) * playerProgressRatio;
        const pathLeftEdge = w / 2 - pathWidthAtPlayer / 2;
        const pathRightEdge = w / 2 + pathWidthAtPlayer / 2;
        const playerLeftEdge = this.player.x - this.player.width / 2;
        const playerRightEdge = this.player.x + this.player.width / 2;

        if (playerLeftEdge < pathLeftEdge || playerRightEdge > pathRightEdge) {
            this.gameState = 'gameover';
            this.ui.messageEl.textContent = 'You Fell!';
            this.ui.restartBtn.style.display = 'block';
        }

        // 檢查是否勝利
        if (this.player.progress >= 100) {
            this.gameState = 'win';
            this.ui.messageEl.textContent = 'You Reached the End!';
            this.ui.restartBtn.style.display = 'block';
        }
    }

    onDraw() {
        if (!this.ctx) return;
        const w = this.canvas.width, h = this.canvas.height;
        
        // 繪製背景
        this.ctx.clearRect(0, 0, w, h);
        this.ctx.fillStyle = '#34495e';
        this.ctx.fillRect(0, 0, w, h);

        // 繪製 3D 路徑
        const horizonY = h * 0.6;
        const pathWidthStart = w * 1.5;
        const pathWidthEnd = w * 0.05;

        this.ctx.beginPath();
        this.ctx.moveTo(w / 2 - pathWidthEnd / 2, horizonY);
        this.ctx.lineTo(w / 2 + pathWidthEnd / 2, horizonY);
        this.ctx.lineTo(w / 2 + pathWidthStart / 2, h);
        this.ctx.lineTo(w / 2 - pathWidthStart / 2, h);
        this.ctx.closePath();
        this.ctx.fillStyle = '#95a5a6';
        this.ctx.fill();

        // 繪製路徑上的線條
        this.ctx.strokeStyle = '#7f8c8d';
        this.ctx.lineWidth = 5;
        const lineSpacing = 50;
        const numLines = 20;
        for (let i = 0; i < numLines; i++) {
            const lineWorldY = (i * lineSpacing + this.pathOffset) % (numLines * lineSpacing);
            const lineScreenRatio = lineWorldY / (numLines * lineSpacing);
            const y = horizonY + (h - horizonY) * lineScreenRatio;
            const widthAtY = pathWidthEnd + (pathWidthStart - pathWidthEnd) * lineScreenRatio;
            this.ctx.beginPath();
            this.ctx.moveTo(w / 2 - widthAtY / 2, y);
            this.ctx.lineTo(w / 2 + widthAtY / 2, y);
            this.ctx.stroke();
        }

        // 繪製玩家火柴人
        const playerBaseY = h * 0.9;
        this.ctx.save();
        this.ctx.translate(this.player.x, playerBaseY);
        this.ctx.rotate(this.player.balanceForce * 0.05); // 稍微傾斜身體

        this.ctx.strokeStyle = '#ffd700';
        this.ctx.lineWidth = 8;
        this.ctx.lineCap = 'round';
        
        // 身體
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(0, -50);
        this.ctx.stroke();
        
        // 頭
        this.ctx.beginPath();
        this.ctx.arc(0, -65, 15, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // 手
        this.ctx.beginPath(); this.ctx.moveTo(0, -40); this.ctx.lineTo(-30, -20); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(0, -40); this.ctx.lineTo(30, -20); this.ctx.stroke();
        
        // 腳 (根據踏步狀態擺動)
        const stepOffset = this.isStepping ? 20 : 0;
        this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.lineTo(-20, 30 + stepOffset); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(0, 0); this.ctx.lineTo(20, 30 - stepOffset); this.ctx.stroke();
        
        this.ctx.restore();
        
        // 更新進度條
        this.ui.progressBar.style.width = `${this.player.progress}%`;
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\pose-wall-scene.js 
// src/games/pose-wall-scene.js
import { BaseScene } from '../core/base-scene.js';

class VectorUtils {
    static getAngle(p1, p2, p3) {
        if (!p1 || !p2 || !p3) return 0;
        const a = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const b = Math.hypot(p3.x - p2.x, p3.y - p2.y);
        const c = Math.hypot(p3.x - p1.x, p3.y - p1.y);
        if (a === 0 || b === 0) return 0;
        return Math.acos((a * a + b * b - c * c) / (2 * a * b)) * (180 / Math.PI);
    }
}

const POSE_LIBRARY = {
    'T_POSE': {
        name: 'T-Pose',
        rules: [
            { type: 'angle', points: [11, 13, 15], targetAngle: 180, weight: 2 }, // Left arm
            { type: 'angle', points: [12, 14, 16], targetAngle: 180, weight: 2 }, // Right arm
            { type: 'y_similarity', points: [13, 14], weight: 1 }, // Elbows at same height
        ]
    },
    'Y_POSE': {
        name: 'Y-Pose',
        rules: [
            { type: 'angle', points: [23, 11, 13], targetAngle: 135, weight: 2 }, // Left torso-arm angle
            { type: 'angle', points: [24, 12, 14], targetAngle: 135, weight: 2 }, // Right torso-arm angle
            { type: 'angle', points: [11, 13, 15], targetAngle: 180, weight: 1 }, // Left arm straight
            { type: 'angle', points: [12, 14, 16], targetAngle: 180, weight: 1 }, // Right arm straight
        ]
    }
};

class PoseMatcher {
    constructor(poseName) {
        this.targetPose = POSE_LIBRARY[poseName];
    }
    calculateSimilarity(landmarks) {
        if (!landmarks || !this.targetPose) return 0;
        let totalScore = 0;
        let totalWeight = 0;

        for (const rule of this.targetPose.rules) {
            const pointsAreVisible = rule.points.every(i => landmarks[i] && (landmarks[i].visibility === undefined || landmarks[i].visibility > 0.5));
            if (!pointsAreVisible) continue;

            let similarity = 0;
            const angleTolerance = 30;
            const ySimilarityTolerance = 0.1; // 10% of screen height

            if (rule.type === 'angle') {
                const [p1, p2, p3] = rule.points.map(i => landmarks[i]);
                const currentAngle = VectorUtils.getAngle(p1, p2, p3);
                similarity = Math.max(0, 1 - Math.abs(currentAngle - rule.targetAngle) / angleTolerance);
            } else if (rule.type === 'y_similarity') {
                const [p1, p2] = rule.points.map(i => landmarks[i]);
                similarity = Math.max(0, 1 - Math.abs(p1.y - p2.y) / ySimilarityTolerance);
            }
            
            totalScore += similarity * rule.weight;
            totalWeight += rule.weight;
        }

        return totalWeight > 0 ? (totalScore / totalWeight) * 100 : 0;
    }
}

export class PoseWallScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.debugInfo = null;

        this.walls = [];
        this.spawnWallInterval = null;
        this.currentPoseMatcher = null;
        this.similarityScore = 0;
    }

    renderHTML() {
        return `
            <style>
                .pw-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #000; }
                .pw-scene #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; transform: scaleX(-1); }
                .pw-scene #ui-layer { position: absolute; top: 80px; left: 20px; z-index: 3; color: white; font-family: monospace; font-size: 1.2em; text-shadow: 1px 1px 2px black; pointer-events: none; }
            </style>
            <div class="pw-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="output-canvas"></canvas>
                <div id="ui-layer"><div id="debug-info"></div></div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'none';

        this.canvas = document.getElementById('output-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.debugInfo = document.getElementById('debug-info');
        
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.listenToMotionResults();
        this.startGame();
    }

    onDestroy() {
        if (this.spawnWallInterval) clearInterval(this.spawnWallInterval);
        this.spawnWallInterval = null;
        this.walls = [];
        this.canvas = null;
        this.ctx = null;
        console.log("[PoseWallScene] Timer and walls cleared.");
    }

    startGame() {
        this.walls = [];
        this.spawnWall();
        if (this.spawnWallInterval) clearInterval(this.spawnWallInterval);
        this.spawnWallInterval = setInterval(() => this.spawnWall(), 5000);
    }

    spawnWall() {
        const poseNames = Object.keys(POSE_LIBRARY);
        const randomPoseName = poseNames[Math.floor(Math.random() * poseNames.length)];
        this.currentPoseMatcher = new PoseMatcher(randomPoseName);
        this.walls.push({
            z: 100,
            speed: 0.3,
            poseName: randomPoseName,
            passed: false,
            state: 'approaching' // approaching, passed-check
        });
    }

    onUpdate() {
        if (!this.currentPoseMatcher) return;

        for (let i = this.walls.length - 1; i >= 0; i--) {
            const wall = this.walls[i];
            wall.z -= wall.speed;

            if (wall.z < 10 && wall.z > 5 && wall.state === 'approaching') {
                this.similarityScore = this.currentPoseMatcher.calculateSimilarity(this.latestResults?.poseLandmarks);
                if (this.similarityScore > 75) {
                    wall.passed = true;
                }
                wall.state = 'passed-check';
            }

            if (wall.z < -10) {
                this.walls.splice(i, 1);
            }
        }
        
        this.debugInfo.innerHTML = `Target Pose: ${this.currentPoseMatcher.targetPose.name}<br>Match Score: ${this.similarityScore.toFixed(1)}%`;
    }

    onDraw() {
        if (!this.ctx) return;
        const w = this.canvas.width, h = this.canvas.height;
        
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, w, h);

        // 繪製骨架
        if (this.latestResults && this.latestResults.poseLandmarks) {
            this.ctx.save();
            // 唔需要鏡像，因為 canvas 已經 scaleX(-1)
            drawConnectors(this.ctx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, { color: 'rgba(0, 255, 0, .7)', lineWidth: 3 });
            this.ctx.restore();
        }

        // 繪製牆壁
        this.walls.sort((a, b) => b.z - a.z); // 遠嘅牆先畫
        for (const wall of this.walls) {
            const scale = Math.max(0, (100 - wall.z) / 100);
            const holeWidth = w * scale;
            const holeHeight = h * scale;
            const holeX = (w - holeWidth) / 2;
            const holeY = (h - holeHeight) / 2;

            this.ctx.save();
            this.ctx.globalAlpha = Math.min(1, scale * 2);
            
            let wallColor;
            if (wall.state === 'approaching') {
                wallColor = '#f0f'; // Purple
            } else {
                wallColor = wall.passed ? '#0ff' : '#f44'; // Cyan for pass, Red for fail
            }

            this.ctx.strokeStyle = wallColor;
            this.ctx.lineWidth = Math.max(2, 25 * scale);
            this.ctx.strokeRect(holeX, holeY, holeWidth, holeHeight);
            
            this.ctx.fillStyle = '#fff';
            this.ctx.font = `bold ${Math.max(12, 100 * scale)}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.globalAlpha = 1;
            this.ctx.fillText(POSE_LIBRARY[wall.poseName].name, w / 2, h / 2);

            this.ctx.restore();
        }
    }
}.
// \VSCode_Projects\MotionGameTemplate2\src\games\road-racer-scene.js 
// src/games/road-racer-scene.js
import { BaseScene } from '../core/base-scene.js';

class ObjectManager {
    constructor(scene) {
        this.scene = scene;
        this.objects = [];
        this.spawnCounter = 0;
    }
    reset() {
        this.objects = [];
        this.spawnCounter = 0;
    }
    update(currentSpeed, spawnDistance) {
        const { canvas, gameProgress } = this.scene;
        // 如果 canvas 唔存在，就唔做任何嘢，防止出錯
        if (!canvas) return;

        this.spawnCounter += currentSpeed;
        if (this.spawnCounter > spawnDistance && gameProgress < 0.95) {
            this.spawnCounter = 0;
            this.spawnObject();
        }
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            obj.y += currentSpeed;
            if (obj.y > canvas.height + 50 && obj.type !== 'finish-line') {
                this.objects.splice(i, 1);
            }
        }
    }
    spawnObject() {
        const { world, canvas } = this.scene;
        const roadStartX = (canvas.width - world.roadWidth) / 2;
        const lane = Math.floor(Math.random() * 3);
        const rand = Math.random();
        const type = rand < 0.5 ? 'collectible' : rand < 0.85 ? 'obstacle' : 'boost';
        const lastObj = this.objects[this.objects.length - 1];
        if (lastObj && lastObj.lane === lane && lastObj.y < 50) return;
        const newObject = {
            type,
            lane,
            x: roadStartX + (lane + 0.5) * world.laneWidth,
            y: -50,
            width: 50,
            height: 50
        };
        if (type === 'obstacle') {
            newObject.width = world.laneWidth * 0.8;
            newObject.height = 30;
        }
        this.objects.push(newObject);
    }
    spawnFinishLine() {
        const { world, canvas } = this.scene;
        this.objects.push({
            type: 'finish-line',
            x: canvas.width / 2,
            y: -100,
            width: world.roadWidth,
            height: 40
        });
    }
    draw(ctx) {
        this.objects.forEach(obj => {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (obj.type === 'collectible') {
                ctx.fillStyle = '#FFD700';
                ctx.font = `${obj.width}px Arial`;
                ctx.fillText('★', obj.x, obj.y);
            } else if (obj.type === 'obstacle') {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obj.x - obj.width / 2, obj.y - obj.height / 2, obj.width, obj.height);
            } else if (obj.type === 'boost') {
                ctx.fillStyle = '#00C4FF';
                ctx.font = `${obj.width}px Arial`;
                ctx.fillText('⚡', obj.x, obj.y);
            } else if (obj.type === 'finish-line') {
                const s = 20;
                for (let i = 0; i < obj.width / s; i++) {
                    ctx.fillStyle = (i % 2 === 0) ? '#000' : '#FFF';
                    ctx.fillRect(obj.x - obj.width / 2 + i * s, obj.y - obj.height / 2, s, obj.height);
                }
            }
        });
    }
}


export class RoadRacerScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        
        this.lastTimestamp = 0;
        this.score = 0;
        this.gameProgress = 0;
        this.gameState = 'PLAYING';

        this.config = {
            gameTotalDistance: 30000, baseSpeed: 5, boostMultiplier: 1.8,
            boostDuration: 3000, invincibleDuration: 2000, hitSlowdownFactor: 0.3,
            playerHitboxScale: 0.8, spawnDistance: 800
        };

        this.objectManager = new ObjectManager(this);

        this.world = { roadWidth: 0, laneWidth: 0, roadScrollY: 0 };

        this.player = {
            targetLane: 1, x: 0, y: 0, width: 60, height: 100,
            isInvincible: false, invincibleTimer: 0, isSlowed: false,
            slowdownTimer: 0, isBoosted: false, boostTimer: 0
        };
        
        this.handState = { x: 0, isVisible: false };
        
        this._onWindowResize = this._onWindowResize.bind(this);
    }

    renderHTML() {
        return `
            <style>
                .rr-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #4a7852; }
                #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
                #ui-container { position: absolute; top: 20px; left: 20px; right: 20px; z-index: 10; display: flex; justify-content: space-between; align-items: flex-start; color: white; font-family: monospace; font-size: 2em; text-shadow: 2px 2px 4px black; pointer-events: none; }
                #score-area { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; }
                #progress-bar-container { position: relative; width: 20px; height: 80vh; background: rgba(0,0,0,0.3); border-radius: 10px; border: 2px solid white; }
                #progress-bar-fill { position: absolute; bottom: 0; width: 100%; background-color: #ffd700; border-radius: 8px; }
                #win-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 5em; color: #ffd700; display: none; z-index: 20; text-shadow: 0 0 15px black; }
                #debug-hud { position: absolute; bottom: 20px; left: 20px; z-index: 20; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; color: white; font-family: monospace; width: 250px; pointer-events: auto; }
                #debug-hud h4 { margin-top: 0; text-align: center; border-bottom: 1px solid #555; padding-bottom: 5px; }
                .slider-group { display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 10px; font-size: 14px; }
                .slider-group .label-container { display: flex; justify-content: space-between; width: 100%; }
                .slider-group label { margin-bottom: 5px; }
                .slider-group input { width: 100%; }
                #debug-apply-reset { width: 100%; padding: 10px; margin-top: 10px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: none; }
            </style>
            <div class="rr-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <div id="ui-container">
                    <div id="score-area">★ 0</div>
                    <div id="progress-bar-container"><div id="progress-bar-fill" style="height: 0%;"></div></div>
                </div>
                <div id="win-message">YOU WIN!</div>
                <canvas id="game-canvas"></canvas>
                <div id="debug-hud">
                    <div class="slider-group"><div class="label-container"><label for="baseSpeed">Base Speed:</label><span id="baseSpeed-value">5.0</span></div><input type="range" id="baseSpeed" min="1" max="20" step="0.5" value="5"></div>
                    <div class="slider-group"><div class="label-container"><label for="boostMultiplier">Boost Multiplier:</label><span id="boostMultiplier-value">1.8</span></div><input type="range" id="boostMultiplier" min="1.1" max="3" step="0.1" value="1.8"></div>
                    <div class="slider-group"><div class="label-container"><label for="hitSlowdownFactor">Hit Slowdown:</label><span id="hitSlowdownFactor-value">0.3</span></div><input type="range" id="hitSlowdownFactor" min="0.1" max="0.9" step="0.1" value="0.3"></div>
                    <div class="slider-group"><div class="label-container"><label for="invincibleDuration">Invincible (ms):</label><span id="invincibleDuration-value">2000</span></div><input type="range" id="invincibleDuration" min="500" max="5000" step="100" value="2000"></div>
                    <div class="slider-group"><div class="label-container"><label for="playerHitboxScale">Hitbox Scale:</label><span id="playerHitboxScale-value">0.80</span></div><input type="range" id="playerHitboxScale" min="0.5" max="1.2" step="0.05" value="0.8"></div>
                    <button id="debug-apply-reset" data-motion-activatable>Apply & Reset</button>
                </div>
            </div>
        `;
    }

    onInit() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.ui = {
            score: document.getElementById('score-area'),
            progressBar: document.getElementById('progress-bar-fill'),
            winMessage: document.getElementById('win-message')
        };
        
        this.motionEngine.setMode('hands');
        this.motionEngine.outputCanvas.style.display = 'block';
        this.motionEngine.outputCanvas.style.opacity = '0.2';
        
        this._bindEvents();
        this.resetGame();
    }

    onDestroy() {
        this.objectManager.reset();
        this.objectManager = null;
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        this.motionEngine.outputCanvas.style.opacity = '1';
        console.log("[RoadRacerScene] Destroyed.");
    }
    
    _bindEvents() {
        this.addManagedEventListener(document.getElementById('debug-apply-reset'), 'click', () => this.resetGame());
        
        const debugSliders = this.container.querySelectorAll('#debug-hud input[type="range"]');
        debugSliders.forEach(slider => {
            const configKey = slider.id;
            const valueSpan = this.container.querySelector(`#${configKey}-value`);
            
            if (this.config[configKey] !== undefined && valueSpan) {
                slider.value = this.config[configKey];
                valueSpan.textContent = parseFloat(slider.value).toFixed(configKey === 'playerHitboxScale' ? 2 : 1);

                this.addManagedEventListener(slider, 'input', (e) => {
                    const val = parseFloat(e.target.value);
                    this.config[configKey] = val;
                    valueSpan.textContent = val.toFixed(configKey === 'playerHitboxScale' ? 2 : 1);
                });
            }
        });

        this.listenToMotionResults();
        this.addManagedEventListener(window, 'resize', this._onWindowResize);
    }
    
    resetGame() {
        this.score = 0;
        this.gameProgress = 0;
        this.gameState = 'PLAYING';
        if (this.ui.winMessage) this.ui.winMessage.style.display = 'none';

        Object.assign(this.player, {
            targetLane: 1, isInvincible: false, invincibleTimer: 0,
            isSlowed: false, slowdownTimer: 0, isBoosted: false, boostTimer: 0
        });

        this._onWindowResize();
        if (this.canvas) {
            this.player.x = this.canvas.width / 2;
        }

        this.objectManager.reset();
        this.lastTimestamp = 0;
    }
    
    onResults(results) {
        const pointer = this.motionEngine.pointer;
        this.handState.isVisible = pointer && pointer.isVisible;
        if (this.handState.isVisible && window.innerWidth > 0) {
            this.handState.x = pointer.x / window.innerWidth;
        }
    }
    
    onUpdate(timestamp) {
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const deltaTime = timestamp - this.lastTimestamp;
        this.lastTimestamp = timestamp;

        if (this.handState.isVisible) {
            if (this.handState.x < 1 / 3) this.player.targetLane = 0;
            else if (this.handState.x < 2 / 3) this.player.targetLane = 1;
            else this.player.targetLane = 2;
        }

        const roadStartX = (this.canvas.width - this.world.roadWidth) / 2;
        const targetX = roadStartX + (this.player.targetLane + 0.5) * this.world.laneWidth;
        this.player.x += (targetX - this.player.x) * 0.2;

        if (this.gameState === 'FINISHED') return;
        
        ['invincibleTimer', 'slowdownTimer', 'boostTimer'].forEach(timerKey => {
            if (this.player[timerKey] > 0) {
                this.player[timerKey] -= deltaTime;
                if (this.player[timerKey] <= 0) {
                    const flagKey = timerKey.replace('Timer', ''); // e.g., 'isInvincible'
                    this.player[`is${flagKey.charAt(0).toUpperCase() + flagKey.slice(1)}`] = false;
                }
            }
        });

        let currentSpeed = this.config.baseSpeed;
        if (this.player.isBoosted) currentSpeed *= this.config.boostMultiplier;
        if (this.player.isSlowed) currentSpeed *= this.config.hitSlowdownFactor;

        const lastProgress = this.gameProgress;
        this.gameProgress = Math.min(1, this.gameProgress + currentSpeed / this.config.gameTotalDistance);
        if (this.gameProgress >= 1 && lastProgress < 1) {
            this.objectManager.spawnFinishLine();
        }

        this.world.roadScrollY = (this.world.roadScrollY + currentSpeed) % 45;
        this.objectManager.update(currentSpeed, this.config.spawnDistance);
        
        this._checkCollisions();
        
        this.ui.score.textContent = `★ ${this.score}`;
        this.ui.progressBar.style.height = `${this.gameProgress * 100}%`;
    }

    onDraw() {
        if (!this.ctx) return;
        const ctx = this.ctx, w = this.canvas.width, h = this.canvas.height;
        ctx.clearRect(0, 0, w, h);

        const roadX = (w - this.world.roadWidth) / 2;
        ctx.fillStyle = '#444';
        ctx.fillRect(roadX, 0, this.world.roadWidth, h);

        ctx.strokeStyle = 'rgba(255, 255, 255, .6)';
        ctx.lineWidth = 5;
        ctx.setLineDash([25, 20]);
        for (let i = 1; i <= 2; i++) {
            const lineX = roadX + i * this.world.laneWidth;
            ctx.lineDashOffset = -this.world.roadScrollY;
            ctx.beginPath();
            ctx.moveTo(lineX, 0);
            ctx.lineTo(lineX, h);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        this.objectManager.draw(ctx);
        this._drawPlayer();
    }
    
    _checkCollisions() {
        const p = this.player;
        const playerRect = {
            l: p.x - p.width * this.config.playerHitboxScale / 2,
            r: p.x + p.width * this.config.playerHitboxScale / 2,
            t: p.y - p.height * this.config.playerHitboxScale / 2,
            b: p.y + p.height * this.config.playerHitboxScale / 2,
        };

        for (let i = this.objectManager.objects.length - 1; i >= 0; i--) {
            const obj = this.objectManager.objects[i];
            const objRect = {
                l: obj.x - obj.width / 2, r: obj.x + obj.width / 2,
                t: obj.y - obj.height / 2, b: obj.y + obj.height / 2,
            };

            if (playerRect.l < objRect.r && playerRect.r > objRect.l && playerRect.t < objRect.b && playerRect.b > objRect.t) {
                if (obj.type === 'finish-line') {
                    if (this.gameState === 'PLAYING') {
                        this.gameState = 'FINISHED';
                        this.ui.winMessage.style.display = 'block';
                    }
                } else if (obj.type === 'collectible') {
                    this.score += 10;
                    this.objectManager.objects.splice(i, 1);
                } else if (obj.type === 'boost') {
                    this.player.isBoosted = true;
                    this.player.boostTimer = this.config.boostDuration;
                    this.objectManager.objects.splice(i, 1);
                } else if (obj.type === 'obstacle' && !this.player.isInvincible) {
                    this.player.isSlowed = true;
                    this.player.slowdownTimer = this.config.invincibleDuration;
                    this.player.isInvincible = true;
                    this.player.invincibleTimer = this.config.invincibleDuration;
                }
            }
        }
    }

    _drawPlayer() {
        if (!this.ctx) return;
        const p = this.player;
        const ctx = this.ctx;
        
        ctx.save();
        if (p.isInvincible) {
            ctx.globalAlpha = (Math.sin(Date.now() / 100) + 1) / 2 * 0.8 + 0.2;
        }

        ctx.fillStyle = p.isBoosted ? '#00C4FF' : '#ff4136';
        ctx.beginPath();
        const carTopWidth = p.width * 0.8;
        const carTopOffset = (p.width - carTopWidth) / 2;
        ctx.moveTo(p.x - p.width / 2 + carTopOffset, p.y - p.height / 2);
        ctx.lineTo(p.x + p.width / 2 - carTopOffset, p.y - p.height / 2);
        ctx.lineTo(p.x + p.width / 2, p.y + p.height / 2);
        ctx.lineTo(p.x - p.width / 2, p.y + p.height / 2);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'yellow';
        ctx.fillRect(p.x - p.width / 2 + carTopOffset + 5, p.y - p.height / 2 - 2, 10, 5);
        ctx.fillRect(p.x + p.width / 2 - carTopOffset - 15, p.y - p.height / 2 - 2, 10, 5);

        ctx.restore();
    }

    _onWindowResize() {
        if (!this.canvas) return;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.world.roadWidth = this.canvas.width * 0.6;
        this.world.laneWidth = this.world.roadWidth / 3;
        this.player.y = this.canvas.height - (this.player.height / 2) - 40;
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\carry-game-scene.js 
// src/prototypes/carry-game-scene.js
import { BaseScene } from '../core/base-scene.js';

const loadScript = (src) => new Promise((resolve, reject) => {
    if (document.querySelector(`script[src="${src}"]`)) return resolve();
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
    document.head.appendChild(script);
});

export class CarryGameScene extends BaseScene {
    constructor() {
        super();
        this.matterEngine = null;
        this.matterRunner = null;
        this.matterRenderer = null;
        this.skeletonCanvas = null;
        this.skeletonCtx = null;

        this.boxes = [];
        this.carryingBox = null;
        this.hands = {
            left: { x: 0, y: 0, isPinching: false },
            right: { x: 0, y: 0, isPinching: false }
        };
    }

    renderHTML() {
        return `
            <style>
                .cg-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: linear-gradient(#34495e, #2c3e50); cursor: none; }
                .cg-scene #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.4; pointer-events: none; transform: scaleX(-1); }
                .cg-scene #game-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .cg-scene #info-panel { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 3; color: white; font-family: monospace; font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; text-align: center; }
            </style>
            <div class="cg-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="skeleton-canvas"></canvas>
                <div id="game-canvas-container"></div>
                <div id="info-panel">
                    <p>用雙手同時「捏」實任何一個箱嚟搬運</p>
                    <p>嘗試將佢哋疊高！</p>
                </div>
            </div>
        `;
    }

    async onInit() {
        await loadScript("https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js");
        
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'block';

        this.gameCanvasContainer = document.getElementById('game-canvas-container');
        this.skeletonCanvas = document.getElementById('skeleton-canvas');
        this.skeletonCtx = this.skeletonCanvas.getContext('2d');
        this.skeletonCanvas.width = window.innerWidth;
        this.skeletonCanvas.height = window.innerHeight;

        this._setupPhysics();
        this.listenToMotionResults();
        this.resetBoxes();
    }

    onDestroy() {
        if (this.matterRunner) Matter.Runner.stop(this.matterRunner);
        if (this.matterRenderer) {
            Matter.Render.stop(this.matterRenderer);
            if (this.matterRenderer.canvas) this.matterRenderer.canvas.remove();
        }
        if (this.matterEngine) {
            Matter.World.clear(this.matterEngine.world);
            Matter.Engine.clear(this.matterEngine);
        }

        this.matterEngine = this.matterRunner = this.matterRenderer = null;
        this.boxes = [];
        this.carryingBox = null;
        this.skeletonCanvas = this.skeletonCtx = null;

        console.log("[CarryGameScene] Matter.js resources completely destroyed.");
    }
    
    _setupPhysics() {
        const { Engine, Render, Runner, World, Bodies } = Matter;
        this.matterEngine = Engine.create({ enableSleeping: true });
        this.matterRunner = Runner.create();
        this.matterRenderer = Render.create({
            element: this.gameCanvasContainer,
            engine: this.matterEngine,
            options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' }
        });
        this.matterEngine.world.gravity.y = 2;

        const w = window.innerWidth, h = window.innerHeight;
        const ground = Bodies.rectangle(w / 2, h - 30, w, 60, { isStatic: true, render: { fillStyle: '#95a5a6' } });
        World.add(this.matterEngine.world, ground);

        Render.run(this.matterRenderer);
        Runner.run(this.matterRunner, this.matterEngine);
    }
    
    resetBoxes() {
        if (!this.matterEngine) return;
        this.boxes.forEach(box => Matter.Composite.remove(this.matterEngine.world, box));
        this.boxes = [];
        this.carryingBox = null;

        const boxSize = 120, colors = ['#c0392b', '#16a085', '#2980b9'];
        const startY = window.innerHeight - 100 - boxSize / 2;
        const startX = window.innerWidth / 2 - 200;

        for (let i = 0; i < 3; i++) {
            const box = Matter.Bodies.rectangle(startX + i * (boxSize + 50), startY, boxSize, boxSize, {
                id: i, density: 0.01, friction: 0.8, restitution: 0.1, render: { fillStyle: colors[i] }
            });
            this.boxes.push(box);
            Matter.World.add(this.matterEngine.world, box);
        }
    }

    updateHandsState() {
        if (!this.latestResults) return;
        
        const pointers = this.motionEngine.pointers;
        ['left', 'right'].forEach(hand => {
            const state = this.hands[hand];
            const pointer = pointers.find(p => p.hand === hand);
            
            if (pointer && pointer.isVisible) {
                state.x = (1 - pointer.x) * window.innerWidth;
                state.y = pointer.y * window.innerHeight;
            }

            const landmarks = hand === 'left' ? this.latestResults.leftHandLandmarks : this.latestResults.rightHandLandmarks;
            state.isPinching = window.isPinching(landmarks);
        });
    }

    onUpdate() {
        this.updateHandsState();
        const { left: leftHand, right: rightHand } = this.hands;

        if (this.carryingBox) {
            // 如果正在搬運，但鬆手了
            if (!leftHand.isPinching || !rightHand.isPinching) {
                const boxToRelease = this.carryingBox;
                Matter.Body.setStatic(boxToRelease, false); // 解除靜態狀態
                Matter.Sleeping.set(boxToRelease, false);   // 喚醒物體
                boxToRelease.render.fillStyle = boxToRelease.originalColor;
                this.carryingBox = null;
                
                // 輕微延遲後喚醒所有物體，確保物理引擎穩定
                setTimeout(() => {
                    if (this.matterEngine) { // 檢查引擎是否存在
                        const allBodies = Matter.Composite.allBodies(this.matterEngine.world);
                        for (const body of allBodies) {
                            if (!body.isStatic) Matter.Sleeping.set(body, false);
                        }
                    }
                }, 50);

                return;
            }
            // 持續搬運
            Matter.Body.setPosition(this.carryingBox, {
                x: (leftHand.x + rightHand.x) / 2,
                y: (leftHand.y + rightHand.y) / 2
            });
            Matter.Body.setVelocity(this.carryingBox, { x: 0, y: 0 });

        } else {
            // 如果未搬運，檢查是否開始搬運
            if (leftHand.isPinching && rightHand.isPinching) {
                const leftTouched = Matter.Query.point(this.boxes, { x: leftHand.x, y: leftHand.y });
                const rightTouched = Matter.Query.point(this.boxes, { x: rightHand.x, y: rightHand.y });
                
                // 確保雙手捏的是同一個箱子
                if (leftTouched.length > 0 && rightTouched.length > 0 && rightTouched[0].id === leftTouched[0].id) {
                    this.carryingBox = leftTouched[0];
                    this.carryingBox.originalColor = this.carryingBox.render.fillStyle;
                    this.carryingBox.render.fillStyle = '#2ecc71'; // 變綠表示被抓住
                    Matter.Body.setStatic(this.carryingBox, true); // 設為靜態，脫離物理控制
                }
            }
        }
    }

    onDraw() {
        if (!this.skeletonCtx || !this.latestResults) return;
        const w = this.skeletonCanvas.width, h = this.skeletonCanvas.height;
        this.skeletonCtx.clearRect(0, 0, w, h);
        
        if (this.latestResults.image) this.skeletonCtx.drawImage(this.latestResults.image, 0, 0, w, h);
        
        const drawHand = (landmarks, color) => {
            if (landmarks) {
                drawConnectors(this.skeletonCtx, landmarks, HAND_CONNECTIONS, { color, lineWidth: 2 });
                drawLandmarks(this.skeletonCtx, landmarks, { color, radius: 4 });
            }
        };
        drawHand(this.latestResults.leftHandLandmarks, '#00FFFF');
        drawHand(this.latestResults.rightHandLandmarks, '#FFD700');
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\marionette-scene.js 
// src/prototypes/marionette-scene.js
import { BaseScene } from '../core/base-scene.js';

// Vector2D 點嘅平滑器
class PointSmoother2D {
    constructor(smoothingFactor = 0.8) {
        this.smoothingFactor = smoothingFactor;
        this.point = null; // 儲存 {x, y}
    }
    update(rawPoint) {
        if (rawPoint) {
            if (this.point) {
                this.point.x = this.smoothingFactor * this.point.x + (1 - this.smoothingFactor) * rawPoint.x;
                this.point.y = this.smoothingFactor * this.point.y + (1 - this.smoothingFactor) * rawPoint.y;
            } else {
                this.point = { ...rawPoint };
            }
            return this.point;
        }
        return null;
    }
}

export class MarionetteScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.character = null;
        
        this.targets = { leftHand: null, rightHand: null, leftFoot: null, rightFoot: null };
        this.smoothers = {
            leftHand: new PointSmoother2D(0.6),
            rightHand: new PointSmoother2D(0.6),
            leftFoot: new PointSmoother2D(0.6),
            rightFoot: new PointSmoother2D(0.6)
        };
    }

    renderHTML() {
        return `
            <style>
                .marionette-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #1a1a1a; }
                #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
            </style>
            <div class="marionette-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="game-canvas"></canvas>
            </div>
        `;
    }

    onInit() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.motionEngine.setMode('pose');
        this.motionEngine.outputCanvas.style.display = 'none';

        this.addManagedEventListener(window, 'resize', () => this.resizeAndReset());
        this.listenToMotionResults();
        
        this.resizeAndReset();
    }
    
    resizeAndReset() {
        if (!this.canvas) return;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this._createCharacter();
    }

    onDestroy() {
        this.canvas = null;
        this.ctx = null;
        this.character = null;
        console.log("[MarionetteScene] Destroyed.");
    }
    
    _createCharacter() {
        const w = this.canvas.width, h = this.canvas.height;
        const torsoHeight = h * 0.22;
        const shoulderWidth = w * 0.1;
        const armLength = h * 0.25;
        const legLength = h * 0.3;
        const neckY = h * 0.3;
        const hipY = neckY + torsoHeight;
        const centerX = w / 2;

        this.character = {
            head: { x: centerX, y: neckY - (h * 0.04) },
            neck: { x: centerX, y: neckY },
            hip: { x: centerX, y: hipY },
            leftArm: {
                chain: [{ x: centerX - shoulderWidth / 2, y: neckY }, { x: centerX - shoulderWidth / 2, y: neckY + armLength / 2 }, { x: centerX - shoulderWidth / 2, y: neckY + armLength }],
                lengths: [armLength / 2, armLength / 2]
            },
            rightArm: {
                chain: [{ x: centerX + shoulderWidth / 2, y: neckY }, { x: centerX + shoulderWidth / 2, y: neckY + armLength / 2 }, { x: centerX + shoulderWidth / 2, y: neckY + armLength }],
                lengths: [armLength / 2, armLength / 2]
            },
            leftLeg: {
                chain: [{ x: centerX - shoulderWidth / 4, y: hipY }, { x: centerX - shoulderWidth / 4, y: hipY + legLength / 2 }, { x: centerX - shoulderWidth / 4, y: hipY + legLength }],
                lengths: [legLength / 2, legLength / 2]
            },
            rightLeg: {
                chain: [{ x: centerX + shoulderWidth / 4, y: hipY }, { x: centerX + shoulderWidth / 4, y: hipY + legLength / 2 }, { x: centerX + shoulderWidth / 4, y: hipY + legLength }],
                lengths: [legLength / 2, legLength / 2]
            },
        };
    }
    
    onUpdate() {
        this._updateTargets();
        if (!this.character) return;
        this.solveIK(this.character.leftArm, this.targets.leftHand);
        this.solveIK(this.character.rightArm, this.targets.rightHand);
        this.solveIK(this.character.leftLeg, this.targets.leftFoot);
        this.solveIK(this.character.rightLeg, this.targets.rightFoot);
    }
    
    _updateTargets() {
        if (!this.latestResults || !this.latestResults.poseLandmarks) return;
        
        const w = this.canvas.width, h = this.canvas.height;
        const landmarks = this.latestResults.poseLandmarks;
        const getPoint = (index) => {
            if (!landmarks[index] || landmarks[index].visibility < 0.3) return null;
            return { x: (1 - landmarks[index].x) * w, y: landmarks[index].y * h };
        };

        const targetPoints = {
            leftHand: getPoint(15), rightHand: getPoint(16),
            leftFoot: getPoint(27), rightFoot: getPoint(28)
        };

        for (const key in this.targets) {
            this.targets[key] = this.smoothers[key].update(targetPoints[key]);
        }
    }

    solveIK(limb, target) {
        if (!limb || !target) return;
        const chain = limb.chain;
        const lengths = limb.lengths;
        const numJoints = chain.length;
        const root = { x: chain[0].x, y: chain[0].y }; // 固定根部

        // FABRIK (Forward And Backward Reaching Inverse Kinematics) 算法
        for (let iter = 0; iter < 5; iter++) {
            // Backward pass
            chain[numJoints - 1] = { x: target.x, y: target.y };
            for (let i = numJoints - 2; i >= 0; i--) {
                const dir = { x: chain[i + 1].x - chain[i].x, y: chain[i + 1].y - chain[i].y };
                const dist = Math.hypot(dir.x, dir.y) || 1;
                const ratio = lengths[i] / dist;
                chain[i] = {
                    x: chain[i + 1].x - dir.x * ratio,
                    y: chain[i + 1].y - dir.y * ratio,
                };
            }

            // Forward pass
            chain[0] = { x: root.x, y: root.y };
            for (let i = 0; i < numJoints - 1; i++) {
                // 手肘/膝蓋約束 (簡單版，防止反向彎曲)
                if (i === 0 && chain.length > 2) {
                    const elbow = chain[1];
                    const shoulder = chain[0];
                    if (elbow.y < shoulder.y) elbow.y = shoulder.y + 1; // 簡單地將手肘向下推
                }
                const dir = { x: chain[i + 1].x - chain[i].x, y: chain[i + 1].y - chain[i].y };
                const dist = Math.hypot(dir.x, dir.y) || 1;
                const ratio = lengths[i] / dist;
                chain[i + 1] = {
                    x: chain[i].x + dir.x * ratio,
                    y: chain[i].y + dir.y * ratio,
                };
            }
        }
    }

    onDraw() {
        if (!this.ctx) return;
        const w = this.canvas.width, h = this.canvas.height;
        this.ctx.clearRect(0, 0, w, h);

        // 繪製背景骨架
        if (this.latestResults) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.4;
            this.ctx.translate(w, 0);
            this.ctx.scale(-1, 1);
            if (this.latestResults.image) this.ctx.drawImage(this.latestResults.image, 0, 0, w, h);
            if (this.latestResults.poseLandmarks) {
                drawConnectors(this.ctx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, { color: 'rgba(255,255,255,.5)', lineWidth: 2 });
            }
            this.ctx.restore();
        }

        if (!this.character) return;
        this.ctx.globalAlpha = 1;
        this.ctx.strokeStyle = '#00FF00';
        this.ctx.lineWidth = 12;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        const { head, neck, hip, leftArm, rightArm, leftLeg, rightLeg } = this.character;
        
        // 畫身體
        this.ctx.beginPath(); this.ctx.moveTo(neck.x, neck.y); this.ctx.lineTo(hip.x, hip.y); this.ctx.stroke();
        // 畫頭
        this.ctx.beginPath(); this.ctx.arc(head.x, head.y, 30, 0, Math.PI * 2); this.ctx.stroke();
        
        const drawLimb = (limb) => {
            if (!limb || !limb.chain) return;
            const chain = limb.chain;
            this.ctx.beginPath();
            this.ctx.moveTo(chain[0].x, chain[0].y);
            for (let i = 1; i < chain.length; i++) this.ctx.lineTo(chain[i].x, chain[i].y);
            this.ctx.stroke();
        };
        
        drawLimb(leftArm); drawLimb(rightArm);
        drawLimb(leftLeg); drawLimb(rightLeg);
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\ribbon-painter-scene.js 
// src/prototypes/ribbon-painter-scene.js
import { BaseScene } from '../core/base-scene.js';

class GestureRecognizer {
    static isFist(handLandmarks) {
        if (!handLandmarks) return false;
        try {
            const wrist = handLandmarks[0];
            const isIndexCurled = this.distance(handLandmarks[8], wrist) < this.distance(handLandmarks[5], wrist);
            const isMiddleCurled = this.distance(handLandmarks[12], wrist) < this.distance(handLandmarks[9], wrist);
            const isRingCurled = this.distance(handLandmarks[16], wrist) < this.distance(handLandmarks[13], wrist);
            const isPinkyCurled = this.distance(handLandmarks[20], wrist) < this.distance(handLandmarks[17], wrist);
            return isIndexCurled && isMiddleCurled && isRingCurled && isPinkyCurled;
        } catch (e) {
            return false;
        }
    }
    static distance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }
}

class Ribbon {
    constructor(color) {
        this.points = [];
        this.color = color;
        this.MAX_POINTS = 100;
    }

    addPoint(x, y, speed) {
        const width = 2 + speed * 2;
        const opacity = Math.min(1, 0.1 + speed / 50);
        this.points.push({ x, y, width, opacity });
        if (this.points.length > this.MAX_POINTS) {
            this.points.shift();
        }
    }

    draw(ctx) {
        if (this.points.length < 2) return;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        for (let i = 1; i < this.points.length; i++) {
            const p1 = this.points[i - 1];
            const p2 = this.points[i];
            // 根據點嘅透明度和喺隊列中嘅位置計算最終透明度
            const alpha = p2.opacity * (i / this.points.length);
            ctx.strokeStyle = this.color.replace('%a', alpha);
            ctx.lineWidth = p2.width;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
    }

    clear() {
        this.points = [];
    }
}

export class RibbonPainterScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.hands = {
            left: { ribbon: new Ribbon('rgba(0, 255, 255, %a)'), history: [], isDrawing: false },
            right: { ribbon: new Ribbon('rgba(255, 215, 0, %a)'), history: [], isDrawing: false }
        };
        this.HISTORY_LENGTH = 5;
    }
    
    renderHTML() {
        // data-scene-changer 路徑修正
        return `
            <style>
                .rp-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #0a0a1a; cursor: none; }
                .rp-scene #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .rp-scene #info-panel { position: absolute; top: 80px; left: 20px; z-index: 3; color: white; font-family: monospace; font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; }
                .rp-scene #clear-button { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 15px 30px; font-size: 1.2em; background-color: #c0392b; color: white; border: none; border-radius: 10px; z-index: 4; pointer-events: auto; }
            </style>
            <div class="rp-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="game-canvas"></canvas>
                <div id="info-panel">
                    <p>揸緊拳頭開始畫畫</p>
                    <p>張開手掌停止</p>
                </div>
                <button id="clear-button" data-motion-activatable>清除畫布</button>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'block';

        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        
        this.addManagedEventListener(document.getElementById('clear-button'), 'click', () => {
            this.hands.left.ribbon.clear();
            this.hands.right.ribbon.clear();
        });

        this.listenToMotionResults();
    }

    onDestroy() {
        this.canvas = null;
        this.ctx = null;
        this.hands = null; // 釋放對象引用
        console.log("[RibbonPainterScene] Destroyed.");
    }

    onUpdate() {
        if (!this.latestResults) return;

        const pointers = this.motionEngine.pointers;
        const handLandmarks = {
            left: this.latestResults.leftHandLandmarks,
            right: this.latestResults.rightHandLandmarks
        };

        ['left', 'right'].forEach(hand => {
            const state = this.hands[hand];
            const pointer = pointers.find(p => p.hand === hand);
            const landmarks = handLandmarks[hand];
            
            const isCurrentlyFist = GestureRecognizer.isFist(landmarks);

            if (!state.isDrawing && isCurrentlyFist) {
                // 開始畫畫時清空歷史記錄，避免畫出一條長線
                state.history = [];
            }
            state.isDrawing = isCurrentlyFist;

            if (pointer && pointer.isVisible) {
                const x = (1 - pointer.x) * this.canvas.width;
                const y = pointer.y * this.canvas.height;
                
                // 計算速度
                let speed = 0;
                if (state.history.length > 1) {
                    const last = state.history[state.history.length - 1];
                    speed = Math.hypot(x - last.x, y - last.y);
                }
                
                // 更新歷史記錄
                state.history.push({ x, y });
                if (state.history.length > this.HISTORY_LENGTH) {
                    state.history.shift();
                }

                if (state.isDrawing) {
                    state.ribbon.addPoint(x, y, speed);
                }
            }
        });
    }

    onDraw() {
        if (!this.ctx) return;
        
        // 用半透明黑色背景製造拖影效果
        this.ctx.fillStyle = 'rgba(10, 10, 26, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 繪製骨架
        if (this.latestResults) {
            this.ctx.save();
            this.ctx.translate(this.canvas.width, 0);
            this.ctx.scale(-1, 1);
            this.ctx.globalAlpha = 0.4;
            
            const drawHand = (landmarks, color) => {
                if (landmarks) {
                    drawConnectors(this.ctx, landmarks, HAND_CONNECTIONS, { color, lineWidth: 2 });
                    drawLandmarks(this.ctx, landmarks, { color, radius: 3 });
                }
            };
            drawHand(this.latestResults.leftHandLandmarks, '#00FFFF');
            drawHand(this.latestResults.rightHandLandmarks, '#FFD700');
            
            this.ctx.restore();
        }

        // 繪製絲帶
        this.hands.left.ribbon.draw(this.ctx);
        this.hands.right.ribbon.draw(this.ctx);
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\scale-rotate-scene.js 
// src/prototypes/scale-rotate-scene.js
import { BaseScene } from '../core/base-scene.js';

// **【核心】Three.js 資源徹底銷毀輔助函數**
function disposeThreeJsObject(obj, THREE) {
    if (!obj) return;
    
    // 遍歷所有子物件
    if (obj.children && obj.children.length > 0) {
        // 從後往前刪除，避免數組長度變化問題
        for (let i = obj.children.length - 1; i >= 0; i--) {
            disposeThreeJsObject(obj.children[i], THREE);
        }
    }
    
    // 釋放幾何體
    if (obj.geometry) {
        obj.geometry.dispose();
    }
    
    // 釋放材質，以及材質引用嘅貼圖
    if (obj.material) {
        if (Array.isArray(obj.material)) {
            obj.material.forEach(material => {
                if (material.map) material.map.dispose();
                material.dispose();
            });
        } else {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
        }
    }
    
    // 從父物件中移除
    if (obj.parent) {
        obj.parent.remove(obj);
    }
}

export class ScaleRotateScene extends BaseScene {
    constructor() {
        super();
        this.THREE = null;
        this.renderer = null;
        this.scene = null;
        this.camera = null;
        this.targetObject = null;
        
        this.hands = {
            left: { isPinching: false, pos: null, skeleton: null, smoother: null },
            right: { isPinching: false, pos: null, skeleton: null, smoother: null }
        };
        this.interactionState = { isInteracting: false, lastCenter: null, lastDistance: 0, lastVector: null };
        this.grabLine = null;
        
        this.calibration = { scale: 2.5, xOffset: 0, yOffset: 0.9, zOffset: -1 };
        
        this._onWindowResize = this._onWindowResize.bind(this);
    }

    createSmoother(THREE) {
        return class PointSmoother3D {
            constructor(smoothingFactor = 0.8) {
                this.smoothingFactor = smoothingFactor;
                this.smoothedData = null;
            }
            update(rawData) {
                if (rawData && rawData.landmarks) {
                    if (!this.smoothedData) {
                        this.smoothedData = { landmarks: rawData.landmarks.map(p => p.clone()) };
                    } else {
                        for (let i = 0; i < rawData.landmarks.length; i++) {
                            if (this.smoothedData.landmarks[i] && rawData.landmarks[i]) {
                                this.smoothedData.landmarks[i].lerp(rawData.landmarks[i], 1 - this.smoothingFactor);
                            }
                        }
                    }
                    return this.smoothedData;
                }
                this.smoothedData = null;
                return null;
            }
        }
    }

    renderHTML() {
        return `
            <style>
                .sr-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
                #canvas-container { width: 100%; height: 100%; }
                #info-panel { position: absolute; top: 80px; left: 20px; color: white; font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; }
            </style>
            <div class="sr-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <div id="canvas-container"></div>
                <div id="info-panel">
                    <h3>原型 F: 雙手縮放與旋轉</h3>
                    <p>請同時用雙手做出捏合手勢</p>
                    <p id="left-hand-status">左手: 未檢測到</p>
                    <p id="right-hand-status">右手: 未檢測到</p>
                </div>
            </div>
        `;
    }

    async onInit() {
        const [THREE] = await window.load3DLibs();
        this.THREE = THREE;
        
        const PointSmoother3D = this.createSmoother(THREE);
        this.hands.left.smoother = new PointSmoother3D(0.7);
        this.hands.right.smoother = new PointSmoother3D(0.7);
        this.hands.left.pos = new THREE.Vector3();
        this.hands.right.pos = new THREE.Vector3();
        
        this.container = document.getElementById('canvas-container');
        this.ui = {
            leftStatus: document.getElementById('left-hand-status'),
            rightStatus: document.getElementById('right-hand-status'),
        };

        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'none';
        
        this._setup3DScene();
        this._addObjects();
        this._bindEvents();
    }

    onDestroy() {
        console.log("[ScaleRotateScene] Starting destruction of Three.js resources...");
        
        // **【核心】** 徹底銷毀 Three.js 場景
        if (this.scene) {
            disposeThreeJsObject(this.scene, this.THREE);
            this.scene = null;
        }

        // 銷毀渲染器
        if (this.renderer) {
            this.renderer.dispose(); // 釋放 WebGL context
            if (this.renderer.domElement.parentElement) {
                this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);
            }
            this.renderer = null;
        }

        this.camera = null;
        this.targetObject = null;
        this.hands = null;
        this.THREE = null;
        
        console.log("[ScaleRotateScene] Three.js resources completely destroyed.");
    }
    
    _bindEvents() {
        this.addManagedEventListener(window, 'resize', this._onWindowResize);
        this.listenToMotionResults();
    }

    _setup3DScene() {
        const T = this.THREE;
        this.renderer = new T.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.container.appendChild(this.renderer.domElement);
        
        this.scene = new T.Scene();
        this.scene.background = new T.Color(0x1d2d3d);
        
        this.camera = new T.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.5, 4);
        
        this.scene.add(new T.AmbientLight(0xffffff, 0.7));
        const dirLight = new T.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 5, 5);
        this.scene.add(dirLight);
    }

    _addObjects() {
        const T = this.THREE;
        const geometry = new T.BoxGeometry(1, 1, 1);
        const material = new T.MeshStandardMaterial({ color: 0x0099ff, roughness: 0.3, metalness: 0.2 });
        this.targetObject = new T.Mesh(geometry, material);
        this.targetObject.position.y = 1.5;
        this.scene.add(this.targetObject);

        this.scene.add(new T.GridHelper(10, 10));

        this.hands.left.skeleton = this._createHandSkeleton(0xff00ff);
        this.hands.right.skeleton = this._createHandSkeleton(0x00ffff);
        this.scene.add(this.hands.left.skeleton, this.hands.right.skeleton);

        const lineMaterial = new T.LineBasicMaterial({ color: 0xffd700 });
        const lineGeometry = new T.BufferGeometry().setFromPoints([new T.Vector3(), new T.Vector3()]);
        this.grabLine = new T.Line(lineGeometry, lineMaterial);
        this.grabLine.visible = false;
        this.scene.add(this.grabLine);
    }

    _createHandSkeleton(color) {
        const T = this.THREE;
        const skeletonGroup = new T.Group();
        skeletonGroup.visible = false;
        
        const jointMaterial = new T.MeshBasicMaterial({ color: color });
        const jointGeometry = new T.SphereGeometry(0.02, 8, 8);
        for (let i = 0; i < 21; i++) {
            skeletonGroup.add(new T.Mesh(jointGeometry, jointMaterial));
        }

        const boneMaterial = new T.LineBasicMaterial({ color: color });
        for (const connection of window.HAND_CONNECTIONS) {
            const points = [new T.Vector3(), new T.Vector3()];
            const geometry = new T.BufferGeometry().setFromPoints(points);
            skeletonGroup.add(new T.Line(geometry, boneMaterial));
        }
        return skeletonGroup;
    }

    onUpdate() {
        this._updateHandsState();
        if (!this.interactionState.isInteracting && this.targetObject) {
            this.targetObject.rotation.y += 0.005;
        }
    }
    
    onDraw() {
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }

    _updateHandsState() {
        if (!this.latestResults) return;
        
        const landmarksData = {
            left: this.latestResults.leftHandLandmarks,
            right: this.latestResults.rightHandLandmarks
        };

        for (const hand of ['left', 'right']) {
            const landmarks = landmarksData[hand];
            const handState = this.hands[hand];
            const smoothedData = handState.smoother.update(this._landmarksToWorld(landmarks));
            
            if (smoothedData) {
                handState.skeleton.visible = true;
                this._updateSkeleton(handState.skeleton, smoothedData.landmarks);
                
                const indexMCP = smoothedData.landmarks[5];
                const middleMCP = smoothedData.landmarks[9];
                if (indexMCP && middleMCP) {
                    handState.pos.set((indexMCP.x + middleMCP.x) / 2, (indexMCP.y + middleMCP.y) / 2, (indexMCP.z + middleMCP.z) / 2);
                }
                handState.isPinching = window.isPinching(landmarks);
                this.ui[`${hand}Status`].textContent = `${hand}: ${handState.isPinching ? '捏合' : '張開'}`;
            } else {
                handState.skeleton.visible = false;
                handState.isPinching = false;
                this.ui[`${hand}Status`].textContent = `${hand}: 未檢測到`;
            }
        }
        this._handleTwoHandInteraction();
    }

    _landmarksToWorld(landmarks) {
        if (!landmarks || landmarks.length === 0) return null;
        
        const aspect = this.camera.aspect;
        const landmarks3D = [];
        for (const lm of landmarks) {
            let ndcX = -(lm.x * 2 - 1);
            let ndcY = -(lm.y * 2 - 1);
            if (aspect > 1) ndcX *= aspect;
            else ndcY /= aspect;
            
            landmarks3D.push(new this.THREE.Vector3(
                (ndcX * this.calibration.scale) + this.calibration.xOffset,
                (ndcY * this.calibration.scale) + this.calibration.yOffset,
                this.calibration.zOffset + (lm.z * 2) // z 軸深度感應
            ));
        }
        return { landmarks: landmarks3D };
    }

    _updateSkeleton(skeleton, landmarks3D) {
        for (let i = 0; i < landmarks3D.length; i++) {
            if (skeleton.children[i]) skeleton.children[i].position.copy(landmarks3D[i]);
        }
        
        let lineIndex = 21;
        for (const connection of window.HAND_CONNECTIONS) {
            const startPoint = landmarks3D[connection[0]];
            const endPoint = landmarks3D[connection[1]];
            const line = skeleton.children[lineIndex];
            
            if (line && startPoint && endPoint) {
                const positions = line.geometry.attributes.position.array;
                positions.set([...startPoint.toArray(), ...endPoint.toArray()]);
                line.geometry.attributes.position.needsUpdate = true;
            }
            lineIndex++;
        }
    }

    _handleTwoHandInteraction() {
        const { left: leftHand, right: rightHand } = this.hands;
        const isInteractingNow = leftHand.isPinching && rightHand.isPinching;
        
        this.grabLine.visible = isInteractingNow;
        if (isInteractingNow) {
            const linePositions = this.grabLine.geometry.attributes.position.array;
            linePositions.set([...leftHand.pos.toArray(), ...rightHand.pos.toArray()]);
            this.grabLine.geometry.attributes.position.needsUpdate = true;
            
            const currentCenter = new this.THREE.Vector3().addVectors(leftHand.pos, rightHand.pos).multiplyScalar(0.5);
            const currentDistance = leftHand.pos.distanceTo(rightHand.pos);
            const currentVector = new this.THREE.Vector3().subVectors(rightHand.pos, leftHand.pos);
            
            if (!this.interactionState.isInteracting) { // 第一次進入互動
                this.interactionState.lastCenter = currentCenter.clone();
                this.interactionState.lastDistance = currentDistance;
                this.interactionState.lastVector = currentVector.clone();
            } else { // 持續互動
                // 移動
                const deltaCenter = new this.THREE.Vector3().subVectors(currentCenter, this.interactionState.lastCenter);
                this.targetObject.position.add(deltaCenter);
                
                // 縮放
                if (this.interactionState.lastDistance > 0.01) {
                    this.targetObject.scale.multiplyScalar(currentDistance / this.interactionState.lastDistance);
                }
                
                // 旋轉
                if (this.interactionState.lastVector.lengthSq() > 0.0001 && currentVector.lengthSq() > 0.0001) {
                    const quaternion = new this.THREE.Quaternion().setFromUnitVectors(
                        this.interactionState.lastVector.clone().normalize(),
                        currentVector.clone().normalize()
                    );
                    this.targetObject.quaternion.premultiply(quaternion);
                }

                // 更新上一幀狀態
                this.interactionState.lastCenter.copy(currentCenter);
                this.interactionState.lastDistance = currentDistance;
                this.interactionState.lastVector.copy(currentVector);
            }
        }
        this.interactionState.isInteracting = isInteractingNow;
    }
    
    _onWindowResize() {
        if (!this.camera || !this.renderer) return;
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\shape-deformer-scene.js 
// src/prototypes/shape-deformer-scene.js
import { BaseScene } from '../core/base-scene.js';

export class ShapeDeformerScene extends BaseScene {
    constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        
        this.shapePoints = [];
        this.pointRadius = 20;
        
        this.hands = {
            left: { isPinching: false, grabbedPointIndex: -1, isHovering: false, hoveringPointIndex: -1, pinchMissFrames: 0 },
            right: { isPinching: false, grabbedPointIndex: -1, isHovering: false, hoveringPointIndex: -1, pinchMissFrames: 0 }
        };
        this.PINCH_MISS_TOLERANCE = 3; // 容忍 3 幀嘅捏合丟失
    }

    renderHTML() {
        return `
            <style>
                .sd-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #2c3e50; }
                .sd-scene #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .sd-scene #info-panel { position: absolute; top: 80px; left: 20px; z-index: 3; color: white; font-family: monospace; font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; }
            </style>
            <div class="sd-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="game-canvas"></canvas>
                <div id="info-panel">
                    <p>用拇指同食指「捏」住圓點拖動</p>
                    <div id="left-hand-status">左手: -</div>
                    <div id="right-hand-status">右手: -</div>
                </div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'none';

        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.ui = {
            leftStatus: document.getElementById('left-hand-status'),
            rightStatus: document.getElementById('right-hand-status')
        };
        
        this.resetShape();
        this.listenToMotionResults();
    }

    onDestroy() {
        this.canvas = null;
        this.ctx = null;
        this.ui = {};
        this.shapePoints = [];
        console.log("[ShapeDeformerScene] Destroyed.");
    }

    resetShape() {
        const w = this.canvas.width, h = this.canvas.height;
        const centerX = w / 2, centerY = h / 2;
        const radius = Math.min(w, h) * 0.2;
        const sides = 5;
        this.shapePoints = [];
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            this.shapePoints.push({
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            });
        }
    }

    onUpdate() {
        if (!this.latestResults) return;

        const w = this.canvas.width, h = this.canvas.height;
        const landmarksData = {
            left: this.latestResults.leftHandLandmarks,
            right: this.latestResults.rightHandLandmarks
        };

        ['left', 'right'].forEach(hand => {
            const state = this.hands[hand];
            const landmarks = landmarksData[hand];
            
            const wasPinching = state.isPinching;
            const isPinchingNow = window.isPinching(landmarks);

            // 帶有容錯嘅捏合狀態更新
            if (isPinchingNow) {
                state.pinchMissFrames = 0;
            } else {
                state.pinchMissFrames++;
            }
            
            if (state.isPinching) { // 如果之前係捏合狀態
                if (state.pinchMissFrames > this.PINCH_MISS_TOLERANCE) {
                    state.isPinching = false; // 連續多幀丟失先當做鬆開
                }
            } else { // 如果之前係鬆開狀態
                state.isPinching = isPinchingNow; // 立即觸發捏合
            }

            state.isHovering = false;
            
            const pointer = this.motionEngine.pointers.find(p => p.hand === hand);
            if (!pointer || !pointer.isVisible) {
                if (state.grabbedPointIndex !== -1) {
                    state.grabbedPointIndex = -1; // 手消失就放開
                }
                state.isPinching = false; // 手消失就當做冇捏
                return;
            }
            
            const pointerX = (1 - pointer.x) * w;
            const pointerY = pointer.y * h;

            if (state.grabbedPointIndex !== -1) {
                if (state.isPinching) {
                    this.shapePoints[state.grabbedPointIndex].x = pointerX;
                    this.shapePoints[state.grabbedPointIndex].y = pointerY;
                } else {
                    state.grabbedPointIndex = -1; // 鬆手就放開
                }
            } else {
                state.hoveringPointIndex = -1;
                for (let i = 0; i < this.shapePoints.length; i++) {
                    const point = this.shapePoints[i];
                    if (Math.hypot(pointerX - point.x, pointerY - point.y) < this.pointRadius * 1.5) {
                        state.hoveringPointIndex = i;
                        state.isHovering = true;
                        // 只有喺 "鬆開 -> 捏合" 嘅瞬間先觸發抓取
                        if (state.isPinching && !wasPinching) {
                            state.grabbedPointIndex = i;
                        }
                        break;
                    }
                }
            }
            
            // 更新 UI 狀態
            let statusText = `${hand}: `;
            if (state.grabbedPointIndex !== -1) {
                statusText += `抓取緊點 ${state.grabbedPointIndex}`;
            } else if (state.isHovering) {
                statusText += `懸停喺點 ${state.hoveringPointIndex}`;
            } else {
                statusText += (state.isPinching ? '捏合' : '張開');
            }
            this.ui[`${hand}Status`].textContent = statusText;
        });
    }

    onDraw() {
        if (!this.ctx) return;
        const w = this.canvas.width, h = this.canvas.height;
        this.ctx.clearRect(0, 0, w, h);

        // 繪製背景骨架
        if (this.latestResults) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.3;
            this.ctx.translate(w, 0);
            this.ctx.scale(-1, 1);
            if (this.latestResults.image) this.ctx.drawImage(this.latestResults.image, 0, 0, w, h);
            
            const drawHand = (landmarks, color) => {
                if (landmarks) {
                    drawConnectors(this.ctx, landmarks, HAND_CONNECTIONS, { color, lineWidth: 2 });
                    drawLandmarks(this.ctx, landmarks, { color, radius: 3 });
                }
            };
            drawHand(this.latestResults.leftHandLandmarks, '#0FF');
            drawHand(this.latestResults.rightHandLandmarks, '#FFD700');
            this.ctx.restore();
        }

        // 繪製形狀連線
        this.ctx.strokeStyle = 'rgba(255, 255, 255, .8)';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(this.shapePoints[0].x, this.shapePoints[0].y);
        for (let i = 1; i < this.shapePoints.length; i++) {
            this.ctx.lineTo(this.shapePoints[i].x, this.shapePoints[i].y);
        }
        this.ctx.closePath();
        this.ctx.stroke();

        // 繪製控制點
        this.shapePoints.forEach((point, i) => {
            const isLeftGrabbed = this.hands.left.grabbedPointIndex === i;
            const isRightGrabbed = this.hands.right.grabbedPointIndex === i;
            const isLeftHovered = this.hands.left.hoveringPointIndex === i && this.hands.left.isHovering;
            const isRightHovered = this.hands.right.hoveringPointIndex === i && this.hands.right.isHovering;

            let color = '#3498db'; // Default
            if (isLeftGrabbed) color = '#0FF';      // Left hand grab
            else if (isRightGrabbed) color = '#FFD700'; // Right hand grab
            else if (isLeftHovered || isRightHovered) color = '#e74c3c'; // Hover
            
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, this.pointRadius, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\throw-3d-scene.js 
// src/prototypes/throw-3d-scene.js
import { BaseScene } from '../core/base-scene.js';

// **【核心】Three.js 資源徹底銷毀輔助函數**
function disposeThreeJsObject(obj, THREE) {
    if (!obj) return;
    
    if (obj.children && obj.children.length > 0) {
        for (let i = obj.children.length - 1; i >= 0; i--) {
            disposeThreeJsObject(obj.children[i], THREE);
        }
    }
    
    if (obj.geometry) {
        obj.geometry.dispose();
    }
    
    if (obj.material) {
        if (Array.isArray(obj.material)) {
            obj.material.forEach(material => {
                if (material.map) material.map.dispose();
                material.dispose();
            });
        } else {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
        }
    }
    
    if (obj.parent) {
        obj.parent.remove(obj);
    }
}

export class Throw3DScene extends BaseScene {
    constructor() {
        super();
        this.THREE = null;
        this.CANNON = null;
        this.renderer = null;
        this.scene = null;
        this.camera = null;
        this.physicsWorld = null;
        
        this.hands = {
            left: { skeleton: null, state: { x: 0, y: 0, z: 0, isPinching: false, isVisible: false, history: [] }, smoother: null },
            right: { skeleton: null, state: { x: 0, y: 0, z: 0, isPinching: false, isVisible: false, history: [] }, smoother: null }
        };
        this.gameobjects = [];
        this.ball = null;
        this.ballMaterial = null;
        this.wallMaterial = null;
        this.ballState = 'idle';
        this.grabbingHand = null;

        this.calibration = { scale: 2.5, xOffset: 0.0, yOffset: 0.9, zOffset: -1.0 };
        this.lastTime = 0;
        this.ATTRACT_SPEED = 5;
        this.GRAB_DISTANCE = 0.4;
        this.THROW_MULTIPLIER = 50;

        this._onWindowResize = this._onWindowResize.bind(this);
    }
    
    renderHTML() {
        return `
            <style>
                .throw3d-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
                #canvas-container { width: 100%; height: 100%; z-index: 1; }
                #info-panel { position: absolute; top: 20px; left: 20px; z-index: 3; color: white; font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; max-width: 300px; }
                #reset-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 4; padding: 10px 20px; font-size: 1em; background-color: #ffd700; color: #1a1a1a; border: none; border-radius: 8px; cursor: none; pointer-events: auto; }
            </style>
            <div class="throw3d-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <div id="canvas-container"></div>
                <div id="info-panel">
                    <h3>3D 投擲</h3>
                    <p>用任何一隻手捏合，即可吸附個波</p>
                    <p id="ball-status">Ball State: idle</p>
                </div>
                <button id="reset-button" data-motion-activatable>Reset Ball</button>
            </div>
        `;
    }
    
    createSmoother(THREE) {
        return class PointSmoother3D {
            constructor(smoothingFactor) {
                this.smoothingFactor = smoothingFactor;
                this.smoothedData = null;
            }
            update(rawData) {
                if (rawData && rawData.landmarks) {
                    if (!this.smoothedData) {
                        this.smoothedData = { landmarks: rawData.landmarks.map(p => p.clone()) };
                    } else {
                        for (let i = 0; i < rawData.landmarks.length; i++) {
                            if (this.smoothedData.landmarks[i] && rawData.landmarks[i]) {
                                this.smoothedData.landmarks[i].lerp(rawData.landmarks[i], 1 - this.smoothingFactor);
                            }
                        }
                    }
                    return this.smoothedData;
                }
                this.smoothedData = null;
                return null;
            }
        }
    }
    
    async onInit() {
        const [THREE, CANNON] = await window.load3DLibs();
        this.THREE = THREE;
        this.CANNON = CANNON;
        
        const PointSmoother3D = this.createSmoother(THREE);
        this.hands.left.smoother = new PointSmoother3D(0.7);
        this.hands.right.smoother = new PointSmoother3D(0.7);
        
        this.container = document.getElementById('canvas-container');
        this.ui = {
            ballStatus: document.getElementById('ball-status'),
            resetButton: document.getElementById('reset-button')
        };
        
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'block';
        
        this._setup3DScene();
        this._setupPhysics();
        this._addObjects();
        this._bindEvents();
        
        this.lastTime = performance.now();
    }

    onDestroy() {
        console.log("[Throw3DScene] Starting destruction of Three.js & Cannon.js resources...");
        
        if (this.physicsWorld) {
            while (this.physicsWorld.bodies.length > 0) {
                this.physicsWorld.removeBody(this.physicsWorld.bodies[0]);
            }
            this.physicsWorld = null;
        }

        if (this.scene) {
            disposeThreeJsObject(this.scene, this.THREE);
            this.scene = null;
        }

        if (this.renderer) {
            this.renderer.dispose();
            if (this.renderer.domElement.parentElement) {
                this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);
            }
            this.renderer = null;
        }
        
        this.camera = null;
        this.gameobjects = [];
        this.ball = null;
        this.hands = null;
        this.THREE = null;
        this.CANNON = null;
        
        console.log("[Throw3DScene] All 3D and physics resources completely destroyed.");
    }
    
    _bindEvents() {
        this.addManagedEventListener(this.ui.resetButton, 'click', () => this.resetBall());
        this.addManagedEventListener(window, 'resize', this._onWindowResize);
        this.listenToMotionResults();
    }

    _setup3DScene() {
        const T = this.THREE;
        this.renderer = new T.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.container.appendChild(this.renderer.domElement);
        this.scene = new T.Scene();
        this.scene.background = new T.Color(0x22223b);
        this.camera = new T.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.5, 3);
        const aL = new T.AmbientLight(0xffffff, 0.6);
        this.scene.add(aL);
        const dL = new T.DirectionalLight(0xffffff, 1.0);
        dL.position.set(5, 10, 7.5);
        dL.castShadow = true;
        this.scene.add(dL);
    }

    _setupPhysics() {
        const C = this.CANNON;
        this.physicsWorld = new C.World({ gravity: new C.Vec3(0, -9.82, 0) });
        this.physicsWorld.broadphase = new C.SAPBroadphase(this.physicsWorld);
        this.physicsWorld.allowSleep = true;
        this.wallMaterial = new C.Material('wall');
        this.ballMaterial = new C.Material('ball');
        const contactMaterial = new C.ContactMaterial(this.wallMaterial, this.ballMaterial, { friction: 0.4, restitution: 0.7 });
        this.physicsWorld.addContactMaterial(contactMaterial);
        const groundBody = new C.Body({ mass: 0, shape: new C.Plane(), material: this.wallMaterial });
        groundBody.quaternion.setFromAxisAngle(new C.Vec3(1, 0, 0), -Math.PI / 2);
        this.physicsWorld.addBody(groundBody);
    }
    
    _addObjects() {
        const T = this.THREE;
        const groundGeometry = new T.PlaneGeometry(20, 20);
        const groundMaterial = new T.MeshStandardMaterial({ color: 0x4a4e69 });
        const groundMesh = new T.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        this.scene.add(groundMesh);
        
        const grid = new T.GridHelper(20, 20, 0x888888, 0x444444);
        grid.position.y = 0.01;
        this.scene.add(grid);
        
        const ballRadius = 0.2;
        const ballMaterial = new T.MeshStandardMaterial({ color: 0xfca311 });
        const ballGeometry = new T.SphereGeometry(ballRadius, 32, 32);
        const ballMesh = new T.Mesh(ballGeometry, ballMaterial);
        ballMesh.position.set(0, 1, -1);
        ballMesh.castShadow = true;
        this.scene.add(ballMesh);
        
        this.ball = { mesh: ballMesh, body: null };
        this.createBallBody();
        this.gameobjects.push(this.ball);
        
        this.hands.left.skeleton = this._createHandSkeleton(0xff00ff);
        this.hands.right.skeleton = this._createHandSkeleton(0x00ffff);
        this.scene.add(this.hands.left.skeleton);
        this.scene.add(this.hands.right.skeleton);
    }
    
    _createHandSkeleton(color) {
        const T = this.THREE;
        const s = new T.Group();
        s.visible = false;
        const jm = new T.MeshBasicMaterial({ color: color, opacity: 0.8, transparent: true });
        const jg = new T.SphereGeometry(0.02, 8, 8);
        for (let i = 0; i < 21; i++) {
            s.add(new T.Mesh(jg.clone(), jm.clone()));
        }
        const bm = new T.LineBasicMaterial({ color: color, opacity: 0.8, transparent: true });
        for (const con of window.HAND_CONNECTIONS) {
            const p = [new T.Vector3(), new T.Vector3()];
            const g = new T.BufferGeometry().setFromPoints(p);
            s.add(new T.Line(g, bm.clone()));
        }
        return s;
    }
    
    onUpdate(timestamp) {
        if (!this.physicsWorld) return;
        
        const deltaTime = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        
        this._updateGameLogic();
        
        this.physicsWorld.step(1 / 60, deltaTime, 3);
        
        if (this.ball && this.ball.body && this.ball.body.position.length() > 6) {
            this.ball.body.velocity.negate(this.ball.body.velocity);
        }
        
        for (const obj of this.gameobjects) {
            if (obj.body && obj.mesh) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }
        }
    }
    
    onDraw() {
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    onResults(results) {
        this._updateHandsState(results);
    }
    
    _updateHandsState(results) {
        if (!this.hands) return;
        const d = { left: results.leftHandLandmarks, right: results.rightHandLandmarks };
        for (const h of ['left', 'right']) {
            const o = this.hands[h];
            const s = o.smoother.update(this.landmarksToWorld(d[h]));
            if (s) {
                o.state.isVisible = true;
                o.skeleton.visible = true;
                this.updateSkeleton(o.skeleton, s.landmarks);
                const i = s.landmarks[5], m = s.landmarks[9];
                if (i && m) {
                    o.state.x = (i.x + m.x) / 2;
                    o.state.y = (i.y + m.y) / 2;
                    o.state.z = (i.z + m.z) / 2;
                    o.state.history.push({ pos: new this.CANNON.Vec3(o.state.x, o.state.y, o.state.z), time: performance.now() });
                    if (o.state.history.length > 10) o.state.history.shift();
                }
                o.state.isPinching = window.isPinching(d[h]);
            } else {
                o.state.isVisible = false;
                o.skeleton.visible = false;
                o.state.isPinching = false;
                o.state.history = [];
            }
        }
    }
    
    landmarksToWorld(landmarks) {
        if (!landmarks || landmarks.length === 0) return null;
        const aspect = this.camera.aspect;
        const landmarks3D = [];
        for (let i = 0; i < landmarks.length; i++) {
            const lm = landmarks[i];
            let ndcX = -(lm.x * 2 - 1);
            let ndcY = -(lm.y * 2 - 1);
            if (aspect > 1) {
                ndcX *= aspect;
            } else {
                ndcY /= aspect;
            }
            const worldPos = new this.THREE.Vector3(
                (ndcX * this.calibration.scale) + this.calibration.xOffset,
                (ndcY * this.calibration.scale) + this.calibration.yOffset,
                this.calibration.zOffset + (lm.z * 2)
            );
            landmarks3D.push(worldPos);
        }
        return { landmarks: landmarks3D };
    }
    
    updateSkeleton(skeleton, landmarks3D) {
        for (let i = 0; i < landmarks3D.length; i++) {
            if (skeleton.children[i]) {
                skeleton.children[i].position.copy(landmarks3D[i]);
            }
        }
        let lineIndex = 21;
        for (const c of window.HAND_CONNECTIONS) {
            const start = landmarks3D[c[0]];
            const end = landmarks3D[c[1]];
            const line = skeleton.children[lineIndex];
            if (line && start && end) {
                const positions = line.geometry.attributes.position.array;
                positions.set([...start.toArray(), ...end.toArray()]);
                line.geometry.attributes.position.needsUpdate = true;
            }
            lineIndex++;
        }
    }

    _updateGameLogic() {
        if (!this.ball || !this.ui.ballStatus || !this.hands) return;
        if (this.ballState === 'grabbing') {
            const handState = this.hands[this.grabbingHand].state;
            const handPos = new this.THREE.Vector3(handState.x, handState.y, handState.z);
            this.ball.mesh.position.lerp(handPos, 0.3);
            if (!handState.isPinching) {
                this.ballState = 'thrown';
                this.createBallBody();
                if (handState.history.length > 2) {
                    const oldest = handState.history[0];
                    const newest = handState.history[handState.history.length - 1];
                    const timeDiff = (newest.time - oldest.time) / 1000;
                    if (timeDiff > 0) {
                        const velocity = newest.pos.vsub(oldest.pos);
                        velocity.scale(1 / timeDiff, velocity);
                        const throwVelocity = velocity.scale(this.THROW_MULTIPLIER);
                        this.ball.body.velocity.copy(throwVelocity);
                    }
                }
                handState.history = [];
                this.grabbingHand = null;
            }
        } else if (this.ballState === 'idle' || this.ballState === 'thrown') {
            let attractingHand = null;
            for (const h of ['left', 'right']) {
                if (this.hands[h].state.isVisible && this.hands[h].state.isPinching) {
                    attractingHand = h;
                    break;
                }
            }
            if (attractingHand && this.ball.body) {
                const handState = this.hands[attractingHand].state;
                const handPos = new this.CANNON.Vec3(handState.x, handState.y, handState.z);
                const distance = handPos.distanceTo(this.ball.body.position);
                const direction = handPos.vsub(this.ball.body.position).unit();
                const attractVelocity = direction.scale(this.ATTRACT_SPEED);
                this.ball.body.velocity.lerp(attractVelocity, 0.2, this.ball.body.velocity);
                if (distance < this.GRAB_DISTANCE) {
                    this.ballState = 'grabbing';
                    this.grabbingHand = attractingHand;
                    if (this.ball.body) {
                        this.physicsWorld.removeBody(this.ball.body);
                        this.ball.body = null;
                    }
                }
            }
        }
        this.ui.ballStatus.textContent = `Ball State: ${this.ballState}`;
    }
    
    resetBall() {
        if (!this.ball || !this.physicsWorld) return;
        this.ballState = 'idle';
        const resetPosition = new this.THREE.Vector3(0, 1, -1);
        this.ball.mesh.position.copy(resetPosition);
        
        if (this.ball.body) {
            this.ball.body.position.copy(resetPosition);
            this.ball.body.velocity.set(0, 0, 0);
            this.ball.body.angularVelocity.set(0, 0, 0);
        } else {
            this.createBallBody();
        }
    }

    createBallBody() {
        if (!this.physicsWorld || !this.ball) return;
        if (this.ball.body) this.physicsWorld.removeBody(this.ball.body);
        
        const C = this.CANNON;
        const shape = new C.Sphere(this.ball.mesh.geometry.parameters.radius);
        const body = new C.Body({ mass: 1, shape, material: this.ballMaterial });
        body.position.copy(this.ball.mesh.position);
        this.physicsWorld.addBody(body);
        this.ball.body = body;
    }

    _onWindowResize() {
        if (!this.camera || !this.renderer) return;
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\prototypes\throw-game-scene.js 
// src/prototypes/throw-game-scene.js
import { BaseScene } from '../core/base-scene.js';

const loadScript = (src) => new Promise((resolve, reject) => {
    if (document.querySelector(`script[src="${src}"]`)) return resolve();
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
    document.head.appendChild(script);
});

export class ThrowGameScene extends BaseScene {
    constructor() {
        super();
        this.matterEngine = null;
        this.matterRunner = null;
        this.matterRenderer = null;
        
        this.skeletonCanvas = null;
        this.skeletonCtx = null;
        
        this.ball = null;
        this.ballState = 'idle'; // idle, grabbing, thrown
        this.grabbingHand = null;
        
        this.handStates = {
            left: { x: 0, y: 0, history: [], isPinching: false },
            right: { x: 0, y: 0, history: [], isPinching: false }
        };
        this.HISTORY_LENGTH = 5;
    }

    renderHTML() {
        return `
            <style>
                .tg-scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; background-color: #334; cursor: none; }
                .tg-scene #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.3; pointer-events: none; transform: scaleX(-1); }
                .tg-scene #game-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
                .tg-scene #info-panel { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 3; color: white; font-family: monospace; font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; text-align: center; }
            </style>
            <div class="tg-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <canvas id="skeleton-canvas"></canvas>
                <div id="game-canvas-container"></div>
                <div id="info-panel">
                    <p>將手靠近個波，然後用拇指同食指「捏」實佢</p>
                    <p>揮動並鬆開手指嚟掟個波</p>
                </div>
            </div>
        `;
    }

    async onInit() {
        await loadScript("https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js");
        
        this.motionEngine.setMode('holistic');
        this.motionEngine.outputCanvas.style.display = 'block';

        this.gameCanvasContainer = document.getElementById('game-canvas-container');
        this.skeletonCanvas = document.getElementById('skeleton-canvas');
        this.skeletonCtx = this.skeletonCanvas.getContext('2d');
        
        this._setupPhysics();
        this.listenToMotionResults();
        this.resetBall();
    }

    onDestroy() {
        if (this.matterRunner) Matter.Runner.stop(this.matterRunner);
        if (this.matterRenderer) {
            Matter.Render.stop(this.matterRenderer);
            if (this.matterRenderer.canvas) this.matterRenderer.canvas.remove();
        }
        if (this.matterEngine) {
            Matter.World.clear(this.matterEngine.world);
            Matter.Engine.clear(this.matterEngine);
        }
        
        this.matterEngine = this.matterRunner = this.matterRenderer = null;
        this.ball = null;
        this.skeletonCanvas = this.skeletonCtx = null;

        console.log("[ThrowGameScene] Matter.js resources completely destroyed.");
    }

    _setupPhysics() {
        const { Engine, Render, Runner, World, Bodies } = Matter;
        this.matterEngine = Engine.create({ enableSleeping: true });
        this.matterRunner = Runner.create();
        this.matterRenderer = Render.create({
            element: this.gameCanvasContainer,
            engine: this.matterEngine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent'
            }
        });
        
        this.matterEngine.world.gravity.y = 1;
        
        const w = window.innerWidth, h = window.innerHeight;
        const wallOptions = { isStatic: true, render: { fillStyle: 'transparent' } };
        World.add(this.matterEngine.world, [
            Bodies.rectangle(w / 2, h + 30, w, 60, wallOptions), // floor
            Bodies.rectangle(-30, h / 2, 60, h, wallOptions),    // left
            Bodies.rectangle(w + 30, h / 2, 60, h, wallOptions),  // right
            Bodies.rectangle(w / 2, -30, w, 60, wallOptions)   // top
        ]);
        
        Render.run(this.matterRenderer);
        Runner.run(this.matterRunner, this.matterEngine);
    }
    
    resetBall() {
        if (!this.matterEngine) return;
        if (this.ball) Matter.Composite.remove(this.matterEngine.world, this.ball);
        
        this.ball = Matter.Bodies.circle(window.innerWidth / 2, window.innerHeight / 2, 30, {
            restitution: 0.7,
            render: { fillStyle: '#e74c3c' }
        });
        Matter.World.add(this.matterEngine.world, this.ball);
        
        this.ballState = 'idle';
        this.grabbingHand = null;
    }

    updateHandsState() {
        if (!this.latestResults) return;
        
        const landmarksData = {
            left: this.latestResults.leftHandLandmarks,
            right: this.latestResults.rightHandLandmarks
        };

        ['left', 'right'].forEach(hand => {
            const state = this.handStates[hand];
            const landmarks = landmarksData[hand];
            const pointer = this.motionEngine.pointers.find(p => p.hand === hand);

            state.isPinching = window.isPinching(landmarks);

            if (pointer && pointer.isVisible) {
                state.x = (1 - pointer.x) * window.innerWidth;
                state.y = pointer.y * window.innerHeight;
                state.history.push({ x: state.x, y: state.y, time: performance.now() });
                if (state.history.length > this.HISTORY_LENGTH) {
                    state.history.shift();
                }
            }
        });
    }
    
    onUpdate() {
        this.updateHandsState();
        if (!this.ball) return;

        if (this.ballState === 'grabbing') {
            const state = this.handStates[this.grabbingHand];
            if (state && state.isPinching) {
                Matter.Body.setPosition(this.ball, { x: state.x, y: state.y });
                Matter.Body.setVelocity(this.ball, { x: 0, y: 0 });
            } else {
                // 鬆手，掟個波出去
                this.ballState = 'thrown';
                this.ball.render.fillStyle = '#e74c3c'; // 還原顏色
                if (state && state.history.length === this.HISTORY_LENGTH) {
                    const oldest = state.history[0];
                    const newest = state.history[state.history.length - 1];
                    const timeDiff = (newest.time - oldest.time) / 1000;
                    if (timeDiff > 0) {
                        const vx = (newest.x - oldest.x) / timeDiff * 0.05; // 調整力度
                        const vy = (newest.y - oldest.y) / timeDiff * 0.05;
                        Matter.Body.setVelocity(this.ball, { x: vx, y: vy });
                    }
                }
                this.grabbingHand = null;
            }
        } else {
            // 檢查係咪抓取
            for (const hand of ['left', 'right']) {
                const state = this.handStates[hand];
                if (state.isPinching && Math.hypot(state.x - this.ball.position.x, state.y - this.ball.position.y) < this.ball.circleRadius * 1.5) {
                    this.ballState = 'grabbing';
                    this.grabbingHand = hand;
                    this.ball.render.fillStyle = hand === 'left' ? '#0FF' : '#FFD700'; // 根據手改變顏色
                    Matter.Sleeping.set(this.ball, false); // 喚醒個波
                    break;
                }
            }
            // 如果掟出後個波瞓著咗，就重置
            if (this.ballState === 'thrown' && this.ball.isSleeping) {
                this.resetBall();
            }
        }
    }
    
    onDraw() {
        if (!this.skeletonCtx || !this.latestResults) return;
        const w = this.skeletonCanvas.width = window.innerWidth;
        const h = this.skeletonCanvas.height = window.innerHeight;
        this.skeletonCtx.clearRect(0, 0, w, h);
        
        if (this.latestResults.image) {
            this.skeletonCtx.drawImage(this.latestResults.image, 0, 0, w, h);
        }

        const drawHand = (landmarks, color) => {
            if (landmarks) {
                drawConnectors(this.skeletonCtx, landmarks, HAND_CONNECTIONS, { color, lineWidth: 2 });
            }
        };
        drawHand(this.latestResults.leftHandLandmarks, '#0FF');
        drawHand(this.latestResults.rightHandLandmarks, '#FFD700');
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\scenes\launcher-scene.js 
// src/scenes/launcher-scene.js
import { BaseScene } from '../core/base-scene.js';

export class LauncherScene extends BaseScene {
    constructor() {
        super();
        this.onCardClick = this.onCardClick.bind(this);
    }

    renderHTML() {
        return `
            <div class="launcher-scene">
                <h1>Motion Games Platform</h1>
                <div class="launcher-grid">
                    <a data-scene="games/road-racer" class="card" data-motion-activatable style="border-color: #00bcd4;"><div><h2>公路賽車手</h2></div><div class="tags"><span class="tag">🏎️ Racing</span><span class="tag">🖐️ Hands</span></div></a>
                    <a data-scene="games/magic-guardian" class="card" data-motion-activatable><div><h2>魔法守護者</h2></div><div class="tags"><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="games/pose-wall" class="card" data-motion-activatable><div><h2>姿勢之牆</h2></div><div class="tags"><span class="tag">🚶 Pose</span></div></a>
                    <a data-scene="games/motion-beat" class="card" data-motion-activatable><div><h2>動感節拍</h2></div><div class="tags"><span class="tag">🚶 Pose</span></div></a>
                    <a data-scene="games/cup-knock" class="card" data-motion-activatable><div><h2>撞杯子</h2></div><div class="tags"><span class="tag">🖐️ Hands</span></div></a>
                    <a data-scene="games/path-of-balance" class="card" data-motion-activatable><div><h2>平衡之道</h2></div><div class="tags"><span class="tag">🚶 Pose</span></div></a>
                    <a data-scene="games/energy-flow" class="card" data-motion-activatable><div><h2>能量引導</h2></div><div class="tags"><span class="tag">🚶 Pose</span></div></a>
                    <a data-scene="games/joint-painter" class="card" data-motion-activatable><div><h2>關節繪畫</h2></div><div class="tags"><span class="tag">🚶 Pose</span></div></a>
                    <a data-scene="prototypes/scale-rotate" class="card" data-motion-activatable style="border-color: #FF9800;"><div><h2 style="color: #FF9800;">[P] 雙手縮放旋轉</h2></div><div class="tags"><span class="tag">🔄 3D</span><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="prototypes/throw-3d" class="card" data-motion-activatable style="border-color: #FF9800;"><div><h2 style="color: #FF9800;">[P] 3D 投擲</h2></div><div class="tags"><span class="tag">⚾ 3D</span><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="prototypes/marionette" class="card" data-motion-activatable style="border-color: #FF9800;"><div><h2 style="color: #FF9800;">[P] 虛擬提線木偶</h2></div><div class="tags"><span class="tag">🕴️ Rigging</span><span class="tag">🚶 Pose</span></div></a>
                    <a data-scene="prototypes/carry-game" class="card" data-motion-activatable style="border-color: #9c27b0;"><div><h2 style="color: #9c27b0;">[P] 雙手搬運</h2></div><div class="tags"><span class="tag">🙌 Carry</span><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="prototypes/shape-deformer" class="card" data-motion-activatable style="border-color: #4CAF50;"><div><h2 style="color: #4CAF50;">[P] 形狀變形</h2></div><div class="tags"><span class="tag">🤏 Pinch</span><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="prototypes/throw-game" class="card" data-motion-activatable style="border-color: #e91e63;"><div><h2 style="color: #e91e63;">[P] 2D 投擲</h2></div><div class="tags"><span class="tag">👋 Throw</span><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="prototypes/ribbon-painter" class="card" data-motion-activatable style="border-color: #00bcd4;"><div><h2 style="color: #00bcd4;">[P] 能量絲帶</h2></div><div class="tags"><span class="tag">🎨 Creative</span><span class="tag">🧍 Holistic</span></div></a>
                    <a data-scene="scenes/test" class="card" data-motion-activatable><div><h2>調試儀表板</h2></div><div class="tags"><span class="tag">⚙️ DEV</span></div></a>
                </div>
            </div>
        `;
    }

    onInit() {
        this.motionEngine.setMode('hands');
        this.motionEngine.outputCanvas.style.display = 'block';
        
        const cards = this.container.querySelectorAll('.card[data-scene]');
        cards.forEach(card => {
            this.addManagedEventListener(card, 'click', this.onCardClick);
        });
    }

    onCardClick(event) {
        event.preventDefault();
        const sceneName = event.currentTarget.dataset.scene;
        if (sceneName) {
            this.sceneManager.loadScene(sceneName);
        }
    }

    onDestroy() {
        console.log("[LauncherScene] All card listeners automatically removed by BaseScene.");
    }
}..
// \VSCode_Projects\MotionGameTemplate2\src\scenes\test-scene.js 
// src/scenes/test-scene.js
import { BaseScene } from '../core/base-scene.js';

export class TestScene extends BaseScene {
    constructor() {
        super();
        this.ui = {};
        this.currentMode = 'hands';
        this.fps = 0;
        this.lastFrameTime = 0;
    }

    renderHTML() {
        return `
            <style>
                .test-scene { display: grid; grid-template-columns: 1fr 380px; gap: 16px; padding: 16px; padding-top: 80px; height: 100vh; width: 100vw; box-sizing: border-box; background: #1a1a1a; color: white; }
                .test-scene .main-view { background: #2b2b2b; border-radius: 12px; padding: 16px; display: flex; flex-direction: column; }
                .test-scene .video-container { position: relative; width: 100%; flex-grow: 1; background: #000; border-radius: 8px; overflow: hidden; }
                .test-scene #overlay-canvas { position: absolute; width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); }
                .test-scene .control-panel { background: #2b2b2b; border-radius: 12px; padding: 16px; overflow-y: auto; }
                .test-scene .panel-section { margin-bottom: 20px; padding: 16px; background: #3c3c3c; border-radius: 8px; }
                .test-scene .panel-title { font-size: 16px; font-weight: 600; margin-bottom: 12px; color: #ffd700; }
                .test-scene .mode-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
                .test-scene .mode-btn { padding: 10px; background: #555; border: 1px solid #666; border-radius: 6px; color: white; cursor: pointer; transition: all 0.2s; font-size: 14px; pointer-events: auto; }
                .test-scene .mode-btn:hover, .test-scene .mode-btn.motion-hover { background: #666; border-color: #ffd700; }
                .test-scene .mode-btn.active { background: #ffd700; color: #1a1a1a; border-color: #ffd700; font-weight: bold; }
                .test-scene .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
                .test-scene .stat-item { padding: 8px; background: #444; border-radius: 6px; }
                .test-scene .stat-label { font-size: 12px; color: #aaa; margin-bottom: 4px; }
                .test-scene .stat-value { font-size: 18px; font-weight: bold; color: #4CAF50; }
            </style>
            <div class="test-scene">
                <a class="back-button" data-scene-changer="scenes/launcher" data-motion-activatable>
                     <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </a>
                <div class="main-view">
                    <div class="video-container">
                        <canvas id="overlay-canvas"></canvas>
                    </div>
                </div>
                <div class="control-panel">
                    <div class="panel-section">
                        <div class="panel-title">🎯 Detection Mode</div>
                        <div class="mode-buttons">
                            <button class="mode-btn active" data-mode="hands" data-motion-activatable>✋ Hands</button>
                            <button class="mode-btn" data-mode="pose" data-motion-activatable>🚶 Pose</button>
                            <button class="mode-btn" data-mode="holistic" data-motion-activatable>🧍 Holistic</button>
                        </div>
                    </div>
                    <div class="panel-section">
                        <div class="panel-title">📊 Performance Stats</div>
                        <div class="stats">
                            <div class="stat-item">
                                <div class="stat-label">FPS</div>
                                <div class="stat-value" id="fps">0</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    onInit() {
        this.ui.canvas = document.getElementById('overlay-canvas');
        this.ui.ctx = this.ui.canvas.getContext('2d');
        this.ui.fps = document.getElementById('fps');
        
        this.motionEngine.setPointerHand('left');
        this.motionEngine.outputCanvas.style.display = 'block';
        
        this._bindEvents();
        this.switchMode(this.currentMode);
        
        this.lastFrameTime = performance.now();
    }

    onDestroy() {
        this.ui = {};
        console.log("[TestScene] Destroyed.");
    }
    
    _bindEvents() {
        const modeButtons = this.container.querySelectorAll('.mode-btn');
        modeButtons.forEach(btn => {
            this.addManagedEventListener(btn, 'click', (e) => this.switchMode(e.target.dataset.mode));
        });
        
        this.listenToMotionResults();
    }

    onUpdate(timestamp) {
        const delta = timestamp - this.lastFrameTime;
        if (delta > 0 && this.ui.fps) {
            this.fps = 1000 / delta;
            this.ui.fps.textContent = Math.round(this.fps);
        }
        this.lastFrameTime = timestamp;
    }

    onDraw() {
        this.drawOverlays();
    }

    onResults(results) {
        this.latestResults = results;
    }

    switchMode(mode) {
        if (!mode) return;
        this.currentMode = mode;
        this.motionEngine.setMode(mode);
        
        const modeButtons = this.container.querySelectorAll('.mode-btn');
        modeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });
    }

    drawOverlays() {
        if (!this.ui.ctx || !this.latestResults) return;

        const w = this.ui.canvas.width = this.ui.canvas.clientWidth;
        const h = this.ui.canvas.height = this.ui.canvas.clientHeight;
        const ctx = this.ui.ctx;
        
        ctx.save();
        ctx.clearRect(0, 0, w, h);
        
        if (this.latestResults.image) {
            ctx.drawImage(this.latestResults.image, 0, 0, w, h);
        }
        
        const drawConfig = { color: '#00FF00', lineWidth: 4 };
        const landmarkConfig = { color: '#FF0000', radius: 5 };

        switch (this.currentMode) {
            case 'hands':
                if (this.latestResults.multiHandLandmarks) {
                    for (const landmarks of this.latestResults.multiHandLandmarks) {
                        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, drawConfig);
                        drawLandmarks(ctx, landmarks, landmarkConfig);
                    }
                }
                break;
            case 'pose':
                if (this.latestResults.poseLandmarks) {
                    drawConnectors(ctx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, drawConfig);
                    drawLandmarks(ctx, this.latestResults.poseLandmarks, landmarkConfig);
                }
                break;
            case 'holistic':
                if (this.latestResults.poseLandmarks) drawConnectors(ctx, this.latestResults.poseLandmarks, POSE_CONNECTIONS, drawConfig);
                if (this.latestResults.leftHandLandmarks) drawConnectors(ctx, this.latestResults.leftHandLandmarks, HAND_CONNECTIONS, { ...drawConfig, color: '#CC0000' });
                if (this.latestResults.rightHandLandmarks) drawConnectors(ctx, this.latestResults.rightHandLandmarks, HAND_CONNECTIONS, { ...drawConfig, color: '#0000CC' });
                break;
        }
        ctx.restore();
    }
}..
